---
phase: 26-infrastructure-transport-foundation
plan: 03
type: execute
wave: 2
depends_on: [26-01]
files_modified:
  - src/test-utils/test-wrapper.tsx
  - src/test-utils/setup.ts
  - src/__tests__/useProjects.test.ts
  - src/__tests__/useUpdater.test.ts
  - src/__tests__/KanbanBoard.test.tsx
  - src/__tests__/ItemEditorModal.test.tsx
  - src/__tests__/components.test.tsx
  - src/__tests__/backlogSchemas.test.ts
  - src/__tests__/persistence.test.ts
autonomous: true
gap_closure: true
requirements: [TINF-01, TINF-02]
must_haves:
  truths:
    - "`pnpm test` exits 0 — all test files pass"
    - "Components using useTranslation render successfully in tests via global I18nProvider wrapper"
    - "Schema test assertions match the current ItemTypeSchema regex (alphanumeric types allowed)"
    - "ErrorBoundary tests match actual French strings from fr locale"
    - "AIContextIndicator test does not time out waiting for unmocked async module"
  artifacts:
    - path: "src/test-utils/test-wrapper.tsx"
      provides: "Custom render/renderHook wrappers with I18nProvider"
      exports: ["renderWithProviders", "renderHookWithProviders", "TestWrapper"]
    - path: "src/test-utils/setup.ts"
      provides: "Global test setup with Tauri IPC mocks and ai-context module mock"
  key_links:
    - from: "src/__tests__/*.test.{ts,tsx}"
      to: "src/test-utils/test-wrapper.tsx"
      via: "import { renderWithProviders, renderHookWithProviders }"
      pattern: "renderWithProviders|renderHookWithProviders"
    - from: "src/test-utils/test-wrapper.tsx"
      to: "src/i18n/index.tsx"
      via: "I18nProvider wrapping all test renders"
      pattern: "I18nProvider"
---

<objective>
Fix all 134 pre-existing test failures so `pnpm test` exits 0 — completing the SC1 success criterion for Phase 26.

Purpose: The verification report identified 7 failing test files / 134 failing tests. All failures are pre-existing (confirmed on pre-phase commit 43f6d22) but prevent `pnpm test` from exiting 0, which is required by SC1. This gap closure fixes the root causes: missing I18nProvider in test renders, out-of-sync schema test assertions, stale French string assertions in ErrorBoundary tests, and an unmocked async module in AIContextIndicator tests.

Output: All test files pass; `pnpm test` exits 0 with Vitest 4.x.
</objective>

<execution_context>
@C:/Users/Boris/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Boris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-infrastructure-transport-foundation/26-01-SUMMARY.md
@.planning/phases/26-infrastructure-transport-foundation/26-VERIFICATION.md

Key source files:
@src/test-utils/setup.ts
@src/test-utils/tauri-mocks.ts
@src/i18n/index.tsx
@src/i18n/locales/fr.ts
@src/types/backlog.ts
@src/components/ui/ErrorBoundary.tsx
@src/components/ui/AIContextIndicator.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create I18nProvider test wrapper and fix all useTranslation test failures</name>
  <files>
    src/test-utils/test-wrapper.tsx
    src/__tests__/useProjects.test.ts
    src/__tests__/useUpdater.test.ts
    src/__tests__/KanbanBoard.test.tsx
    src/__tests__/ItemEditorModal.test.tsx
    src/__tests__/components.test.tsx
  </files>
  <action>
  **Root cause:** 5 test files render components/hooks that call `useTranslation()` from `src/i18n/index.tsx`. This hook throws `"useTranslation must be used within an I18nProvider"` when no provider is in the React tree. The tests were written before i18n was added (Phase 8) and never updated.

  **Step 1: Create `src/test-utils/test-wrapper.tsx`**

  Create a custom test-utils module following the [React Testing Library custom render pattern](https://testing-library.com/docs/react-testing-library/setup/#custom-render):

  ```tsx
  import { type ReactNode } from 'react';
  import { render, renderHook, type RenderOptions, type RenderHookOptions } from '@testing-library/react';
  import { I18nProvider } from '../i18n';

  function TestWrapper({ children }: { children: ReactNode }) {
    return <I18nProvider defaultLocale="fr">{children}</I18nProvider>;
  }

  function renderWithProviders(ui: React.ReactElement, options?: Omit<RenderOptions, 'wrapper'>) {
    return render(ui, { wrapper: TestWrapper, ...options });
  }

  function renderHookWithProviders<Result, Props>(
    hook: (props: Props) => Result,
    options?: Omit<RenderHookOptions<Props>, 'wrapper'>
  ) {
    return renderHook(hook, { wrapper: TestWrapper, ...options });
  }

  export { renderWithProviders, renderHookWithProviders, TestWrapper };
  // Re-export everything from @testing-library/react for convenience
  export * from '@testing-library/react';
  ```

  **Step 2: Update 5 test files to use the wrapper**

  For each failing test file, make these targeted changes:

  **`src/__tests__/useProjects.test.ts`** (28 failures):
  - Replace `import { renderHook, act } from '@testing-library/react'` with `import { renderHookWithProviders, act } from '../test-utils/test-wrapper'`
  - Replace all `renderHook(() => useProjects())` calls with `renderHookWithProviders(() => useProjects())`

  **`src/__tests__/useUpdater.test.ts`** (24 failures):
  - Replace `import { renderHook, act } from '@testing-library/react'` with `import { renderHookWithProviders, act } from '../test-utils/test-wrapper'`
  - Replace all `renderHook(` calls with `renderHookWithProviders(`

  **`src/__tests__/KanbanBoard.test.tsx`** (15 failures):
  - Replace `import { render, screen, fireEvent } from '@testing-library/react'` with `import { renderWithProviders, screen, fireEvent } from '../test-utils/test-wrapper'`
  - Replace all `render(<KanbanBoard` calls with `renderWithProviders(<KanbanBoard`

  **`src/__tests__/ItemEditorModal.test.tsx`** (18 failures):
  - Replace `import { render, screen, fireEvent, waitFor } from '@testing-library/react'` with `import { renderWithProviders, screen, fireEvent, waitFor } from '../test-utils/test-wrapper'`
  - Replace all `render(<ItemEditorModal` calls with `renderWithProviders(<ItemEditorModal`

  **`src/__tests__/components.test.tsx`** (47 useTranslation failures):
  - Replace `import { render, screen, fireEvent } from '@testing-library/react'` with `import { renderWithProviders as render, screen, fireEvent } from '../test-utils/test-wrapper'`
  - This aliased import (`renderWithProviders as render`) avoids changing every `render(` call in this 1000+ line file — all existing `render()` calls automatically get the wrapper.

  **Step 3: Fix ErrorBoundary test assertions (tests 42, 45, 46)**

  The ErrorBoundary component uses `fr.error.unknown` ("Erreur inconnue") and `fr.action.refresh` ("Actualiser") but the tests look for "Une erreur est survenue" and "Réessayer". Update the test assertions to match the actual French strings:

  - Test 42: Change `screen.getByText('Une erreur est survenue')` to `screen.getByText('Erreur inconnue')`
  - Test 45: Change `screen.getByText('Réessayer')` to `screen.getByText('Actualiser')`
  - Test 46: Change `screen.getByText('Une erreur est survenue')` to `screen.getByText('Erreur inconnue')` and `screen.getByText('Réessayer')` to `screen.getByText('Actualiser')`

  **Step 4: Fix AIContextIndicator test 76**

  Test 76 (`renders context badge after loading`) awaits `findByText('CLAUDE')` which times out because `getContextStatus` from `../../lib/ai-context` returns the wrong shape. The existing `vi.mock('../lib/ai-context', ...)` at lines 81-89 of `components.test.tsx` already mocks the module, but `getContextStatus` returns `{ hasClaude, hasAgents, claudeChars, agentsChars }` instead of the `ContextStatus` interface that `AIContextIndicator` accesses via `status.files.length`.

  **Update the existing `vi.mock('../lib/ai-context', ...)` at line 81 of `components.test.tsx`** — do NOT add a second `vi.mock` for the same module (Vitest ignores or errors on duplicates). Change:
  - `loadProjectContext: vi.fn().mockResolvedValue({ files: [{ filename: 'CLAUDE.md', chars: 500 }], loadedAt: Date.now() })`
  - `getContextStatus: vi.fn().mockReturnValue({ files: [{ filename: 'CLAUDE.md', chars: 500 }], loadedAt: Date.now() })`

  This ensures `AIContextIndicator` sees `status.files` as a non-empty array and renders the 'CLAUDE' badge.
  </action>
  <verify>
  Run each fixed test file individually:
  ```bash
  pnpm exec vitest run src/__tests__/useProjects.test.ts
  pnpm exec vitest run src/__tests__/useUpdater.test.ts
  pnpm exec vitest run src/__tests__/KanbanBoard.test.tsx
  pnpm exec vitest run src/__tests__/ItemEditorModal.test.tsx
  pnpm exec vitest run src/__tests__/components.test.tsx
  ```
  All 5 files must show 0 failures.
  </verify>
  <done>
  All 130+ useTranslation failures eliminated. ErrorBoundary tests match actual French strings. AIContextIndicator test 76 passes with mocked ai-context module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix schema and parser test assertions to match current ItemTypeSchema</name>
  <files>
    src/__tests__/backlogSchemas.test.ts
    src/__tests__/persistence.test.ts
  </files>
  <action>
  **Root cause:** The `ItemTypeSchema` regex was updated from `^[A-Z]+$` (letters only) to `^[A-Z][A-Z0-9_]*$` (letters, numbers, underscores) to support dynamic type IDs like `BUG_V5`, `EXT_CHROME`. Two tests assert the old behavior.

  **Fix 1: `src/__tests__/backlogSchemas.test.ts` — Test 3**

  Test 3 (`rejects types with numbers or special chars`) asserts `ItemTypeSchema.safeParse('BUG1').success` is `false`. With the current regex, `BUG1` is valid (starts with letter, contains letters and digits).

  Update test 3 to reflect the current schema behavior:
  ```typescript
  test('3. rejects types with invalid characters or format', () => {
    // Now allows alphanumeric + underscore: BUG1 and BUG_V5 are valid
    expect(ItemTypeSchema.safeParse('BUG1').success).toBe(true);     // was false
    expect(ItemTypeSchema.safeParse('BUG-001').success).toBe(false); // dash not allowed
    expect(ItemTypeSchema.safeParse('').success).toBe(false);        // empty
    expect(ItemTypeSchema.safeParse('1BUG').success).toBe(false);    // starts with number
    expect(ItemTypeSchema.safeParse('bug_v5').success).toBe(false);  // lowercase
  });
  ```

  **Fix 2: `src/__tests__/persistence.test.ts` — Test 6**

  Test 6 (`getTypeFromId returns null for invalid IDs`) asserts `getTypeFromId('BUG001')` returns `null`. With the current schema, `getTypeFromId` splits on `-`, gets `BUG001`, and `ItemTypeSchema.safeParse('BUG001')` succeeds because `BUG001` matches `^[A-Z][A-Z0-9_]*$`.

  The function `getTypeFromId('BUG001')` correctly returns `'BUG001'` as the type prefix — `BUG001` has no dash so `split('-')[0]` returns the full string, and it IS a valid type ID now.

  Update the assertion:
  ```typescript
  expect(getTypeFromId('BUG001')).toBe('BUG001'); // valid type ID (no dash = full string is the type)
  ```

  This reflects the intentional behavior: `BUG001` with no dash means the entire string is treated as the type prefix, and since it matches the current regex, it's returned as valid.
  </action>
  <verify>
  ```bash
  pnpm exec vitest run src/__tests__/backlogSchemas.test.ts
  pnpm exec vitest run src/__tests__/persistence.test.ts
  ```
  Both files must show 0 failures (18/18 and 20/20 pass).
  </verify>
  <done>
  Schema and parser test assertions match the current `ItemTypeSchema` regex. Both test files pass completely.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify pnpm test exits 0</name>
  <files></files>
  <action>
  Run the full test suite to confirm all gaps are closed:

  ```bash
  pnpm test
  ```

  **Expected result:** All test files pass. Exit code 0. Zero `useTranslation` errors. Zero `__TAURI_INTERNALS__` errors.

  If any test still fails:
  - Read the failure output carefully
  - Fix the root cause in the failing test file
  - Re-run to confirm

  Also verify the build still passes:
  ```bash
  pnpm build
  ```

  **IMPORTANT:** Do not introduce any `console.log` statements. Do not leave unused imports. The gap closure must be clean.
  </action>
  <verify>
  ```bash
  pnpm test
  pnpm build
  ```
  Both commands exit 0.
  </verify>
  <done>
  `pnpm test` exits 0 with Vitest 4.x. `pnpm build` passes. SC1 fully satisfied. All 134 pre-existing test failures are resolved.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **SC1 fully verified:** `pnpm test` exits 0 with Vitest 4.x and zero `__TAURI_INTERNALS__` errors
2. **No regressions:** `pnpm build` passes without errors
3. **Clean code:** No unused imports, no console.log debug statements, no `any` types
4. **Tests are accurate:** Schema tests match current regex behavior, French strings match actual locale file
</verification>

<success_criteria>
- `pnpm test` exits 0 — zero failing tests across all test files
- `pnpm build` passes without errors
- No new files created except `src/test-utils/test-wrapper.tsx`
- All existing tests still validate the correct behavior (not just disabled or skipped)
</success_criteria>

<output>
After completion, create `.planning/phases/26-infrastructure-transport-foundation/26-03-SUMMARY.md`
</output>
