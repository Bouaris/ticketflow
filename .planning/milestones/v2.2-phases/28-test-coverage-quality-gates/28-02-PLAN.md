---
phase: 28-test-coverage-quality-gates
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/__tests__/ai-retry.test.ts
  - src/__tests__/ai-health.test.ts
autonomous: true
requirements: [TCOV-03, TCOV-04]
must_haves:
  truths:
    - "ai-retry tests verify no retry on 401 auth error (generate called exactly once)"
    - "ai-retry tests verify no retry on 403 forbidden error (generate called exactly once)"
    - "ai-retry tests verify no retry on 429 rate limit error (generate called exactly once)"
    - "ai-retry tests verify retry on 500 server error (generate called more than once, succeeds on retry)"
    - "ai-retry tests verify successful first-attempt parse returns success with retryCount 0"
    - "ai-retry tests verify retry with error feedback on invalid JSON"
    - "ai-health tests verify auth classification for 401 error"
    - "ai-health tests verify auth classification for 403 error"
    - "ai-health tests verify rate_limit classification for 429 error"
    - "ai-health tests verify timeout classification for AbortError"
    - "ai-health tests verify network classification for ECONNREFUSED"
    - "ai-health tests verify unknown classification for unrecognized errors"
    - "ai-health tests verify success result with latencyMs on healthy provider"
  artifacts:
    - path: "src/__tests__/ai-retry.test.ts"
      provides: "Unit tests for generateWithRetry, getStructuredOutputMode, zodToSimpleJsonSchema"
      exports: []
    - path: "src/__tests__/ai-health.test.ts"
      provides: "Unit tests for testProviderHealth error classification"
      exports: []
  key_links:
    - from: "src/__tests__/ai-retry.test.ts"
      to: "src/lib/ai-retry.ts"
      via: "import { generateWithRetry, getStructuredOutputMode, zodToSimpleJsonSchema }"
      pattern: "generateWithRetry|getStructuredOutputMode"
    - from: "src/__tests__/ai-health.test.ts"
      to: "src/lib/ai-health.ts"
      via: "import { testProviderHealth }"
      pattern: "testProviderHealth"
---

<objective>
Create comprehensive unit test suites for ai-retry.ts and ai-health.ts — both currently at 0% coverage. These are pure logic modules that can be tested entirely with mocks.

Purpose: ai-retry handles AI generation retry logic with error classification (rate limit, auth errors) — critical for user-facing error handling. ai-health provides the 5-type error classification used by ProviderCard health checks. Both are testable without Tauri IPC.

Output: Two new test files (ai-retry.test.ts, ai-health.test.ts) bringing both modules above the 70% line coverage threshold.
</objective>

<execution_context>
@C:/Users/Boris/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Boris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-test-coverage-quality-gates/28-RESEARCH.md

@src/lib/ai-retry.ts
@src/lib/ai-health.ts
@src/lib/abort.ts
@src/test-utils/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ai-retry.test.ts with retry logic and capability detection tests</name>
  <files>src/__tests__/ai-retry.test.ts</files>
  <action>
Create `src/__tests__/ai-retry.test.ts` with the following structure:

**Mocks (at top level, hoisted by vitest):**

```typescript
vi.mock('../lib/ai-provider-registry', () => ({
  getProviderById: vi.fn(() => null),
}));

vi.mock('../i18n', () => ({
  getTranslations: () => ({
    aiErrors: {
      rateLimitReached: 'Rate limit reached',
      invalidApiKey: 'Invalid API key',
    },
  }),
}));
```

The ai-provider-registry mock returns null so getStructuredOutputMode falls through to using the raw provider string as the type. The i18n mock provides the two error messages used by generateWithRetry's catch block.

**Test Suite 1: generateWithRetry**

1. "returns success on first attempt when generate returns valid JSON"
   - Schema: `z.object({ result: z.string() })`
   - generate mock: resolves `'{"result": "hello"}'`
   - Assert: `result.success === true`, `result.data.result === 'hello'`, `result.retryCount === 0`

2. "does NOT retry on 429 rate limit error"
   - generate mock: rejects `new Error('429 Too Many Requests')`
   - maxRetries: 3
   - Assert: `result.success === false`, `generate` called exactly 1 time, error contains 'Rate limit'

3. "does NOT retry on 401 auth error"
   - generate mock: rejects `new Error('401 Unauthorized')`
   - maxRetries: 3
   - Assert: `result.success === false`, `generate` called exactly 1 time, error contains 'API key'

4. "does NOT retry on 403 forbidden error"
   - generate mock: rejects `new Error('403 Forbidden')`
   - maxRetries: 3
   - Assert: `result.success === false`, `generate` called exactly 1 time

5. "retries on 500 server error and succeeds on retry"
   - generate mock: first call rejects `new Error('500 Internal Server Error')`, second resolves `'{"result": "ok"}'`
   - maxRetries: 1
   - Assert: `result.success === true`, `generate` called 2 times, `result.retryCount === 1`

6. "retries on invalid JSON and includes error feedback in retry prompt"
   - generate mock: first call resolves `'not json at all'`, second resolves `'{"result": "fixed"}'`
   - maxRetries: 1
   - Assert: `result.success === true`
   - Assert: second call's prompt argument contains `[CORRECTION REQUIRED]`

7. "retries on Zod validation failure with detailed error"
   - Schema: `z.object({ name: z.string(), age: z.number() })`
   - generate mock: first call resolves `'{"name": 123}'` (wrong type), second resolves `'{"name": "Alice", "age": 30}'`
   - maxRetries: 1
   - Assert: `result.success === true`, `result.data.name === 'Alice'`

8. "returns failure when all retries exhausted"
   - generate mock: always resolves `'not json'`
   - maxRetries: 2
   - Assert: `result.success === false`, `generate` called 3 times (1 initial + 2 retries)

**Test Suite 2: getStructuredOutputMode**

9. "returns strict for known Groq strict model"
   - Assert: `getStructuredOutputMode('groq', 'llama-3.3-70b-specdec') === 'strict'`

10. "returns bestEffort for known Groq bestEffort model"
    - Assert: `getStructuredOutputMode('groq', 'llama-3.3-70b-versatile') === 'bestEffort'`

11. "returns schema for known Gemini model"
    - Assert: `getStructuredOutputMode('gemini', 'gemini-2.5-flash') === 'schema'`

12. "returns none for unknown provider"
    - Assert: `getStructuredOutputMode('unknown-provider', 'some-model') === 'none'`

**Test Suite 3: zodToSimpleJsonSchema**

13. "converts simple object schema"
    - Schema: `z.object({ name: z.string(), count: z.number() })`
    - Assert result has `type: 'object'`, has `properties.name` and `properties.count`, has `additionalProperties: false`

14. "converts schema with enum"
    - Schema: `z.object({ status: z.enum(['active', 'inactive']) })`
    - Assert result.properties.status has `enum` array

Use `beforeEach(() => vi.clearAllMocks())` in each describe block.
  </action>
  <verify>Run `pnpm test src/__tests__/ai-retry.test.ts` — all 14 tests pass. Run `pnpm test:coverage -- --reporter=text src/lib/ai-retry.ts 2>&1 | grep ai-retry` — shows >= 70% line coverage.</verify>
  <done>ai-retry.test.ts has 14 tests covering: retry logic (no retry on 429/401/403, retry on 500, error feedback), capability detection, and JSON schema conversion. Line coverage >= 70%.</done>
</task>

<task type="auto">
  <name>Task 2: Create ai-health.test.ts with 5-type error classification tests</name>
  <files>src/__tests__/ai-health.test.ts</files>
  <action>
Create `src/__tests__/ai-health.test.ts` with the following structure:

**Mocks (at top level, hoisted by vitest):**

```typescript
vi.mock('../lib/ai', () => ({
  testProviderConnection: vi.fn(),
}));

vi.mock('../lib/telemetry', () => ({
  track: vi.fn(),
}));

vi.mock('../lib/abort', () => ({
  createTimeoutController: vi.fn(() => {
    const controller = new AbortController();
    // Attach a mock _timeoutId for clearControllerTimeout
    (controller as AbortController & { _timeoutId?: number })._timeoutId = 123;
    return controller;
  }),
  clearControllerTimeout: vi.fn(),
  isAbortError: vi.fn((err: unknown) => err instanceof DOMException && (err as DOMException).name === 'AbortError'),
}));
```

IMPORTANT: The `isAbortError` mock must be a function that actually checks `DOMException + AbortError name`, because `ai-health.ts` calls `isAbortError(error)` — if the mock just returns false, the timeout test will fall through to 'unknown'.

**Import after mocks:**
```typescript
import { testProviderHealth } from '../lib/ai-health';
import { testProviderConnection } from '../lib/ai';
import { track } from '../lib/telemetry';
```

**Test Suite: testProviderHealth — Error Classification**

Use `beforeEach(() => vi.clearAllMocks())`.

1. "returns success with latencyMs on healthy provider"
   - `vi.mocked(testProviderConnection).mockResolvedValue(undefined)`
   - Assert: `result.success === true`, `result.latencyMs` is a number >= 0, no errorType

2. "classifies 401 error as auth"
   - `vi.mocked(testProviderConnection).mockRejectedValue(new Error('401 Unauthorized'))`
   - Assert: `result.success === false`, `result.errorType === 'auth'`, `result.error === 'Invalid API key'`

3. "classifies 403 error as auth"
   - `vi.mocked(testProviderConnection).mockRejectedValue(new Error('403 Forbidden'))`
   - Assert: `result.success === false`, `result.errorType === 'auth'`

4. "classifies 'invalid api key' error as auth"
   - `vi.mocked(testProviderConnection).mockRejectedValue(new Error('invalid api key provided'))`
   - Assert: `result.errorType === 'auth'`

5. "classifies 429 error as rate_limit"
   - `vi.mocked(testProviderConnection).mockRejectedValue(new Error('429 rate limit exceeded'))`
   - Assert: `result.success === false`, `result.errorType === 'rate_limit'`, `result.error === 'Rate limit reached'`

6. "classifies resource exhausted as rate_limit"
   - `vi.mocked(testProviderConnection).mockRejectedValue(new Error('resource exhausted'))`
   - Assert: `result.errorType === 'rate_limit'`

7. "classifies AbortError as timeout"
   - Create a real DOMException: `new DOMException('The operation was aborted', 'AbortError')`
   - `vi.mocked(testProviderConnection).mockRejectedValue(abortError)`
   - Assert: `result.success === false`, `result.errorType === 'timeout'`, `result.error === 'Connection timeout'`

8. "classifies ECONNREFUSED as network"
   - `vi.mocked(testProviderConnection).mockRejectedValue(new Error('ECONNREFUSED'))`
   - Assert: `result.success === false`, `result.errorType === 'network'`, `result.error === 'Network error'`

9. "classifies ENOTFOUND as network"
   - `vi.mocked(testProviderConnection).mockRejectedValue(new Error('ENOTFOUND'))`
   - Assert: `result.errorType === 'network'`

10. "classifies fetch error as network"
    - `vi.mocked(testProviderConnection).mockRejectedValue(new Error('fetch failed'))`
    - Assert: `result.errorType === 'network'`

11. "classifies unrecognized error as unknown"
    - `vi.mocked(testProviderConnection).mockRejectedValue(new Error('Something completely unexpected'))`
    - Assert: `result.success === false`, `result.errorType === 'unknown'`, `result.error` contains 'Something completely unexpected'

12. "calls track() for every outcome (success and all error types)"
    - After success test: assert `vi.mocked(track)` was called with `'ai_health_check_run'` and `{ success: true, ... }`
    - After auth error test: assert `vi.mocked(track)` was called with `'ai_health_check_run'` and `{ success: false, ... }`
    - (Combine with existing tests or add one dedicated test that checks track is called)

13. "always calls clearControllerTimeout in finally block"
    - After any test (success or failure): assert `clearControllerTimeout` was called exactly once
    - This verifies the finally block cleanup
  </action>
  <verify>Run `pnpm test src/__tests__/ai-health.test.ts` — all 13 tests pass. Run `pnpm test:coverage -- --reporter=text src/lib/ai-health.ts 2>&1 | grep ai-health` — shows >= 70% line coverage.</verify>
  <done>ai-health.test.ts has 13 tests covering all 5 error classifications (auth, rate_limit, timeout, network, unknown) plus success path, telemetry tracking, and cleanup. Line coverage >= 70%.</done>
</task>

</tasks>

<verification>
1. `pnpm test src/__tests__/ai-retry.test.ts` — 14 tests pass
2. `pnpm test src/__tests__/ai-health.test.ts` — 13 tests pass
3. `pnpm test` — all tests pass (no regressions)
4. Both ai-retry.ts and ai-health.ts show >= 70% line coverage in `pnpm test:coverage` output
5. `pnpm build` — passes (no TypeScript errors)
</verification>

<success_criteria>
- ai-retry.test.ts exists with tests verifying: no retry on 429/401/403, retry on 500, error feedback in retry prompt, JSON extraction, Zod validation retry, structured output mode detection
- ai-health.test.ts exists with tests verifying: success path, auth (401/403), rate_limit (429/resource exhausted), timeout (AbortError), network (ECONNREFUSED/ENOTFOUND/fetch), unknown, telemetry tracking, cleanup
- Both modules at >= 70% line coverage
- Zero regressions on existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/28-test-coverage-quality-gates/28-02-SUMMARY.md`
</output>
