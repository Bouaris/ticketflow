---
phase: 27-telemetry-core-consent
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/telemetry.ts
  - src/__tests__/telemetry.test.ts
  - PRIVACY.md
autonomous: true
requirements:
  - TELE-03
  - TELE-07
  - TCOV-05

must_haves:
  truths:
    - "telemetry.ts exports track(), getConsentState(), setConsentState(), shouldPromptConsent(), initTelemetry(), shutdownTelemetry()"
    - "track() is a complete no-op when consent state is not 'granted' (no IPC call, no queue)"
    - "track() sends events via invoke('ph_send_batch') in Tauri mode and via fetch to eu.i.posthog.com/batch in web mode"
    - "Every event payload includes distinct_id, app_version, and platform as super-properties"
    - "Unit tests verify: no-op before consent, events fire after consent, revocation stops events, dismiss count logic"
  artifacts:
    - path: "src/lib/telemetry.ts"
      provides: "Consent gate, event tracking, IPC relay, batch flush"
      exports: ["track", "getConsentState", "setConsentState", "shouldPromptConsent", "getDismissCount", "incrementDismissCount", "initTelemetry", "shutdownTelemetry"]
    - path: "src/__tests__/telemetry.test.ts"
      provides: "TCOV-05 unit tests for consent gate and event firing"
      min_lines: 80
    - path: "PRIVACY.md"
      provides: "Full privacy policy document linked from consent dialog"
      min_lines: 40
  key_links:
    - from: "src/lib/telemetry.ts"
      to: "invoke('ph_send_batch')"
      via: "@tauri-apps/api/core invoke"
      pattern: "invoke\\('ph_send_batch'"
    - from: "src/lib/telemetry.ts"
      to: "localStorage"
      via: "ticketflow-telemetry-consent key"
      pattern: "ticketflow-telemetry-consent"
---

<objective>
Create the core telemetry module (`src/lib/telemetry.ts`) that gates all event tracking behind a localStorage consent check, routes events through the Phase 26 Rust IPC relay (`ph_send_batch`) in Tauri mode (or direct fetch in web mode), and attaches app_version + platform as super-properties on every event. Also create the unit tests (TCOV-05) and the PRIVACY.md file.

Purpose: This is the foundation layer that all other Phase 27 work depends on. No UI or instrumentation can happen without a working telemetry module and consent gate.

Output: `src/lib/telemetry.ts`, `src/__tests__/telemetry.test.ts`, `PRIVACY.md`
</objective>

<execution_context>
@C:/Users/Boris/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Boris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-telemetry-core-consent/27-RESEARCH.md
@src/lib/version.ts
@src/lib/tauri-bridge.ts
@src-tauri/src/telemetry.rs
@src/test-utils/tauri-mocks.ts
@src/test-utils/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create telemetry.ts core module with consent gate and IPC relay</name>
  <files>src/lib/telemetry.ts</files>
  <action>
Create `src/lib/telemetry.ts` implementing Approach B from 27-RESEARCH.md (direct IPC relay, NO posthog-js dependency at runtime). This eliminates posthog-js bundle concerns entirely (SC4 satisfied trivially — zero delta).

**Constants:**
- `CONSENT_KEY = 'ticketflow-telemetry-consent'`
- `DISMISS_COUNT_KEY = 'ticketflow-telemetry-dismiss-count'`
- `DEVICE_ID_KEY = 'ticketflow-telemetry-device-id'`
- `POSTHOG_HOST = 'https://eu.i.posthog.com'` (EU endpoint for GDPR — TELE-07)
- Read `POSTHOG_KEY` from `import.meta.env.VITE_POSTHOG_KEY`

**Consent state types and functions:**
- `type ConsentState = 'granted' | 'declined' | null`
- `getConsentState(): ConsentState` — reads localStorage key, returns null if not set
- `setConsentState(state: 'granted' | 'declined'): void` — writes localStorage
- `getDismissCount(): number` — reads DISMISS_COUNT_KEY, parses int, defaults 0
- `incrementDismissCount(): void` — reads, increments, writes
- `shouldPromptConsent(): boolean` — returns true if consent is null AND dismissCount <= 1 (re-prompt once on second launch if dismissed, then treat as Decline permanently per locked decision: "re-prompt once on next launch, then treat as Decline if ignored again")

**Device ID:**
- `getDeviceId(): string` — reads DEVICE_ID_KEY from localStorage; if null, generates via `crypto.randomUUID()`, stores, returns. This is the anonymous distinct_id for PostHog.

**Super-properties (TELE-07):**
- Import `APP_VERSION` from `./version`
- Import `isTauri` from `./tauri-bridge`
- Build super-props object: `{ distinct_id: getDeviceId(), app_version: APP_VERSION, platform: isTauri() ? 'desktop' : 'web' }`
- Merge into every event's properties

**Event batching and flush:**
- Module-level `pendingEvents` array of `{ event: string; properties: Record<string, unknown>; timestamp: string }`
- Module-level `flushTimer: ReturnType<typeof setTimeout> | null`
- `scheduleFlush(): void` — sets a 100ms debounce timer. On fire:
  1. If no pending events or no POSTHOG_KEY, return
  2. Splice all events out of pendingEvents
  3. If `isTauri()`: call `invoke('ph_send_batch', { events: batch, apiKey: POSTHOG_KEY })` with `.catch(console.warn)`
  4. Else (web mode): call `fetch(POSTHOG_HOST + '/batch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ api_key: POSTHOG_KEY, batch }) })` with `.catch(console.warn)`

**Public track() function:**
- `track(event: string, properties?: Record<string, unknown>): void`
- Gate: if `getConsentState() !== 'granted'`, return immediately (no-op)
- Gate: if `!POSTHOG_KEY`, return (graceful degradation)
- Push to pendingEvents with timestamp `new Date().toISOString()` and merged super-properties
- Call `scheduleFlush()`

**Lifecycle functions:**
- `initTelemetry(): void` — called after consent granted or on app startup when consent already granted. Currently a no-op for Approach B (no posthog-js to initialize), but exists as an API contract for future use. Can fire `track('app_launched')` if called from app startup (not from consent accept — that fires `consent_granted` instead).
- `shutdownTelemetry(): void` — clears the flush timer, flushes remaining events immediately (synchronous best-effort)

**Error tracking hooks (from locked decisions — anonymous unhandled errors):**
- `setupErrorTracking(): void` — registers `window.addEventListener('unhandledrejection', ...)` and `window.addEventListener('error', ...)` handlers that call `track('error_unhandled', { error_message: msg.slice(0, 200) })`. Only fire if consent is granted (check inside handler). Truncate message to 200 chars. No stack traces (could contain file paths — privacy).
- Call `setupErrorTracking()` from `initTelemetry()`.

**Important: Do NOT import posthog-js anywhere.** Approach B means zero external dependency for telemetry at runtime. The only imports are `invoke` from `@tauri-apps/api/core`, `isTauri` from `./tauri-bridge`, and `APP_VERSION` from `./version`.

**TypeScript: No `any`.** Use `Record<string, unknown>` for properties. Export all public functions for testing.
  </action>
  <verify>
`pnpm build` passes. `grep -c "posthog-js" src/lib/telemetry.ts` returns 0 (no posthog-js dependency). The file exports all listed functions.
  </verify>
  <done>
`src/lib/telemetry.ts` exists with consent gate, track(), IPC relay (Tauri) / fetch (web), super-properties (app_version + platform), error tracking, and zero posthog-js dependency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create telemetry unit tests (TCOV-05) and PRIVACY.md</name>
  <files>src/__tests__/telemetry.test.ts, PRIVACY.md</files>
  <action>
**Part A: Unit tests (TCOV-05)**

Create `src/__tests__/telemetry.test.ts` with vitest. The test file will import functions directly from `../lib/telemetry`. The global setup already provides localStorage mock and Tauri IPC mocks (ph_send_batch is stubbed in tauri-mocks.ts).

Use `vi.useFakeTimers()` in beforeEach and `vi.useRealTimers()` in afterEach to control the 100ms flush debounce.

**Important: Module caching.** Since telemetry.ts has module-level state (pendingEvents, flushTimer), and vitest caches modules, use `vi.resetModules()` in beforeEach and dynamically import the module in each test to get fresh state:

```typescript
let telemetry: typeof import('../lib/telemetry');

beforeEach(async () => {
  vi.useFakeTimers();
  vi.resetModules();
  localStorage.clear();
  telemetry = await import('../lib/telemetry');
});
```

**Test cases (minimum 8 tests):**

1. `track() is a no-op before consent is granted` — call track('test'), advance timers, verify invoke was NOT called
2. `track() fires after consent is granted` — setConsentState('granted'), track('test_event', { foo: 'bar' }), advance timers, await flush microtasks, verify invoke was called with correct shape `{ events: [{ event: 'test_event', properties: expect.objectContaining({ foo: 'bar', app_version: expect.any(String), platform: expect.any(String), distinct_id: expect.any(String) }), timestamp: expect.any(String) }], apiKey: expect.any(String) }`
3. `track() stops after consent is revoked` — setConsentState('granted'), then setConsentState('declined'), track('should_not_fire'), advance timers, verify invoke NOT called
4. `shouldPromptConsent() returns true on first launch` — no localStorage set, expect true
5. `shouldPromptConsent() returns true after one dismiss` — incrementDismissCount(), expect shouldPromptConsent() === true (re-prompt once)
6. `shouldPromptConsent() returns false after two dismisses` — incrementDismissCount() x2, expect false
7. `shouldPromptConsent() returns false when consent already granted` — setConsentState('granted'), expect false
8. `getDeviceId() generates and persists a UUID` — call getDeviceId(), verify it's a valid UUID-like string, call again, verify same value returned
9. `track() batches multiple events in single flush` — setConsentState('granted'), call track() 3 times, advance timers once, verify invoke called once with 3 events

**Mock VITE_POSTHOG_KEY:** Use `vi.stubEnv('VITE_POSTHOG_KEY', 'phc_test_key_123')` in beforeEach (or mock `import.meta.env`). If stubEnv is not available, use `vi.mock` to mock the env variable at module level.

**Mock invoke:** The global setup already mocks `ph_send_batch` via setupTauriMocks. To spy on it, import `invoke` from `@tauri-apps/api/core` and use `vi.mocked(invoke)` or re-mock it locally with `vi.mock('@tauri-apps/api/core', ...)`.

**Part B: PRIVACY.md**

Create `PRIVACY.md` in the repository root (per locked decision). This is the full privacy policy document linked from the consent dialog.

Content (in English, ~60 lines):
- Title: "Ticketflow Privacy Policy"
- Last updated date: 2026-02-17
- Section: "Overview" — Ticketflow is a local-first desktop application. All your data stays on your machine.
- Section: "Telemetry" — Ticketflow can collect anonymous usage data to improve the application. This is entirely optional and requires explicit consent.
- Section: "What we collect" — list: feature usage patterns (which views, tools, AI providers), anonymous error reports (truncated messages, no stack traces), app version and platform (desktop/web), anonymous device identifier (random UUID, not linked to identity)
- Section: "What we never collect" — list: file contents or project names, API keys or credentials, personally identifiable information (name, email, IP address), browsing activity or screen content
- Section: "How data is processed" — Events are sent to PostHog (EU servers, eu.i.posthog.com) for aggregation. In desktop mode, events are relayed through a local Rust process. No third-party trackers or advertising networks are involved.
- Section: "Your rights" — You can: decline telemetry on first launch, toggle telemetry off at any time in App Settings > Privacy, all collection stops immediately upon revocation
- Section: "Data retention" — Anonymous event data is retained for 90 days in PostHog, then automatically deleted.
- Section: "Contact" — Link to GitHub issues for questions
- Section: "Changes" — This policy may be updated. Changes will be noted in the app changelog.
  </action>
  <verify>
`pnpm test src/__tests__/telemetry.test.ts` passes with all tests green. `PRIVACY.md` exists in repo root. `pnpm build` still passes.
  </verify>
  <done>
`src/__tests__/telemetry.test.ts` has 8+ tests covering consent gate (no-op before consent, fires after, stops on revocation), dismiss logic (shouldPromptConsent scenarios), device ID persistence, and event batching. `PRIVACY.md` exists at repo root with full privacy policy.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes without errors
2. `pnpm test src/__tests__/telemetry.test.ts` passes with all tests green
3. `grep "posthog-js" src/lib/telemetry.ts` returns nothing (Approach B — no posthog-js dependency)
4. `grep "ph_send_batch" src/lib/telemetry.ts` returns at least 1 match (IPC relay)
5. `grep "eu.i.posthog.com" src/lib/telemetry.ts` returns at least 1 match (EU endpoint)
6. `grep "app_version" src/lib/telemetry.ts` returns at least 1 match (super-property)
7. PRIVACY.md exists at repo root
</verification>

<success_criteria>
- telemetry.ts is a self-contained module with zero external PostHog SDK dependency
- Consent gate provably blocks all event dispatch when consent is not 'granted'
- Super-properties (app_version, platform, distinct_id) are attached to every event
- Unit tests cover the three SC5 scenarios (no-op before consent, fires after, stops on revocation)
- PRIVACY.md provides comprehensive privacy policy for the consent dialog link
</success_criteria>

<output>
After completion, create `.planning/phases/27-telemetry-core-consent/27-01-SUMMARY.md`
</output>
