---
phase: 27-telemetry-core-consent
plan: "02"
type: execute
wave: 2
depends_on: ["27-01"]
files_modified:
  - src/components/consent/ConsentDialog.tsx
  - src/App.tsx
  - src/components/settings/AppSettingsModal.tsx
autonomous: true
requirements:
  - TELE-01
  - TELE-02

must_haves:
  truths:
    - "A new user (no localStorage consent key) sees a centered consent modal on first launch before any telemetry network call"
    - "The Accept and Decline buttons have identical styling (equal visual weight)"
    - "The consent dialog is always in English regardless of app language setting"
    - "Dismissing the dialog (X/Escape) re-prompts once on next launch, then treats as permanent Decline"
    - "A user who previously accepted can toggle telemetry off in App Settings Privacy section; revocation takes effect immediately"
    - "Toggling telemetry off shows inline confirmation message: 'Telemetry disabled. No data will be sent.'"
  artifacts:
    - path: "src/components/consent/ConsentDialog.tsx"
      provides: "First-launch consent modal with equal-weight Accept/Decline buttons"
      min_lines: 60
    - path: "src/App.tsx"
      provides: "Consent dialog wiring, telemetry init on startup"
      contains: "ConsentDialog"
    - path: "src/components/settings/AppSettingsModal.tsx"
      provides: "Privacy section with telemetry toggle"
      contains: "telemetry"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/consent/ConsentDialog.tsx"
      via: "ConsentDialog component render"
      pattern: "<ConsentDialog"
    - from: "src/App.tsx"
      to: "src/lib/telemetry.ts"
      via: "initTelemetry() and track() imports"
      pattern: "initTelemetry"
    - from: "src/components/settings/AppSettingsModal.tsx"
      to: "src/lib/telemetry.ts"
      via: "getConsentState/setConsentState/track imports"
      pattern: "getConsentState|setConsentState"
---

<objective>
Create the consent dialog component and wire it into App.tsx for first-launch display. Add a Privacy section to AppSettingsModal for telemetry revocation. This delivers the GDPR-compliant consent flow: users are prompted before any data collection, can accept or decline with equal-weight buttons, and can revoke at any time from settings.

Purpose: TELE-01 (first-launch consent) and TELE-02 (revocation toggle) are the GDPR requirements. Without them, no telemetry can legally fire.

Output: ConsentDialog.tsx (new), App.tsx (modified), AppSettingsModal.tsx (modified)
</objective>

<execution_context>
@C:/Users/Boris/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Boris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/27-telemetry-core-consent/27-RESEARCH.md
@.planning/phases/27-telemetry-core-consent/27-01-SUMMARY.md
@src/App.tsx
@src/components/settings/AppSettingsModal.tsx
@src/components/ui/Modal.tsx
@src/lib/telemetry.ts
@src/lib/tauri-bridge.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConsentDialog component and wire into App.tsx</name>
  <files>src/components/consent/ConsentDialog.tsx, src/App.tsx</files>
  <action>
**Part A: Create ConsentDialog.tsx**

Create `src/components/consent/ConsentDialog.tsx`. This is the first-launch consent modal.

**Locked decisions to honor:**
- Language: ALWAYS English regardless of app language (hardcoded strings, NOT via i18n system)
- Tone: transparent and detailed — 5-8 lines listing what is collected and what is never collected
- Accept/Decline buttons: EQUAL visual weight (identical styling) — SC1 requirement
- Dismiss (X/Escape): re-prompt once on next launch, then treat as Decline if ignored again
- No PostHog network call before user makes a choice
- Link to PRIVACY.md on GitHub opens in external browser

**Component props:**
```typescript
interface ConsentDialogProps {
  isOpen: boolean;
  onAccept: () => void;
  onDecline: () => void;
  onDismiss: () => void;
}
```

**Layout:** Use the existing `Modal` component from `../ui/Modal`. Centered modal (not banner — per Claude's discretion; fits app's existing modal pattern). Size: `"md"`.

**Modal props:**
- `isOpen={isOpen}`
- `onClose={onDismiss}` — X button maps to dismiss
- `closeOnBackdrop={false}` — must make explicit choice, no accidental backdrop clicks
- `closeOnEscape={true}` — Escape is same as X (dismiss)
- `showCloseButton={true}`
- `size="md"`
- `footer` — renders Accept and Decline buttons

**Content (hardcoded English strings):**
- Title: "Help improve Ticketflow" (using `<h2>` inside the modal body, NOT the modal title prop — more control over layout)
- Description paragraph: "Ticketflow can collect anonymous usage data to help us understand how the app is used and prioritize improvements. You can change this at any time in App Settings."
- "We collect:" list (3 items): feature usage, error reports, app version and platform
- "We never collect:" list (3 items): file contents or project names, API keys or credentials, personally identifiable information
- "Read full privacy policy" link — uses `open()` from `@tauri-apps/plugin-shell` in Tauri mode, `window.open()` in web mode. URL: `https://github.com/Bouaris/ticketflow/blob/master/PRIVACY.md`

**Button styling (CRITICAL — equal weight, SC1):**
Both buttons use `flex-1` (equal width) and IDENTICAL class strings:
```
flex-1 px-4 py-2.5 text-sm font-medium rounded-lg border border-outline text-on-surface hover:bg-surface-alt transition-colors
```
Neither button is highlighted as "primary" (no bg-accent, no text-white). Decline on left, Accept on right. Both in a `flex gap-3 w-full` container.

**Part B: Wire ConsentDialog into App.tsx**

Import `ConsentDialog` from `./components/consent/ConsentDialog`.
Import `getConsentState, setConsentState, shouldPromptConsent, incrementDismissCount, initTelemetry, track` from `./lib/telemetry`.

**State:**
- `const [showConsent, setShowConsent] = useState(false);`

**Initialization useEffect (add new useEffect):**
```typescript
// Telemetry: check consent state on startup
useEffect(() => {
  const consent = getConsentState();
  if (consent === 'granted') {
    // Previously accepted — initialize telemetry and fire app_launched
    initTelemetry();
    track('app_launched');
  } else if (consent === null && shouldPromptConsent()) {
    // First launch or one previous dismiss — show consent dialog
    setShowConsent(true);
  }
  // consent === 'declined' or dismissed twice: do nothing
}, []);
```

**Consent handlers:**
```typescript
const handleConsentAccept = useCallback(() => {
  setConsentState('granted');
  setShowConsent(false);
  initTelemetry();
  track('consent_granted');
  track('app_launched');
}, []);

const handleConsentDecline = useCallback(() => {
  setConsentState('declined');
  setShowConsent(false);
}, []);

const handleConsentDismiss = useCallback(() => {
  incrementDismissCount();
  setShowConsent(false);
  // On next launch, shouldPromptConsent() will check dismiss count
  // and show again if count <= 1, otherwise treat as permanent decline
}, []);
```

**Render ConsentDialog in the global modals section (near the end of App.tsx, alongside other modals):**
```tsx
<ConsentDialog
  isOpen={showConsent}
  onAccept={handleConsentAccept}
  onDecline={handleConsentDecline}
  onDismiss={handleConsentDismiss}
/>
```

Place it BEFORE the UpdateModal (consent should appear first on a fresh launch, before update checks).

**IMPORTANT:** The consent dialog renders INDEPENDENTLY of project state — it can show on the welcome screen or during onboarding. It does NOT block the app (user can interact with the app behind it, but `closeOnBackdrop={false}` prevents accidental dismissal). If onboarding is active and consent dialog shows, both are visible — that's acceptable since onboarding has a solid background and consent is a modal overlay.
  </action>
  <verify>
`pnpm build` passes. The ConsentDialog component compiles. The consent dialog appears only when localStorage has no consent key AND dismiss count is <=1.
  </verify>
  <done>
ConsentDialog.tsx renders a centered modal with equal-weight Accept/Decline buttons, hardcoded English text listing what is/isn't collected, and a link to PRIVACY.md on GitHub. App.tsx shows the dialog on first launch, initializes telemetry on accept or on subsequent launches with prior consent, and handles dismiss with re-prompt logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Privacy section with telemetry toggle to AppSettingsModal</name>
  <files>src/components/settings/AppSettingsModal.tsx</files>
  <action>
Add a "Privacy" section to AppSettingsModal.tsx for telemetry revocation (TELE-02).

**Placement:** After the "Changelog" section and before the "Export" section (since Privacy is a cross-cutting concern, not data-specific). Add a `pt-4 border-t border-outline` divider consistent with other sections.

**Imports to add:**
- `import { getConsentState, setConsentState, initTelemetry, track } from '../../lib/telemetry';`

**State to add:**
```typescript
const [telemetryEnabled, setTelemetryEnabled] = useState(getConsentState() === 'granted');
const [telemetryMessage, setTelemetryMessage] = useState<string | null>(null);
```

**Handler:**
```typescript
const handleTelemetryToggle = useCallback(() => {
  const newEnabled = !telemetryEnabled;
  setTelemetryEnabled(newEnabled);

  if (newEnabled) {
    setConsentState('granted');
    initTelemetry();
    track('consent_granted');
    setTelemetryMessage(null);
  } else {
    // Fire consent_revoked BEFORE changing state (last event)
    track('consent_revoked');
    setConsentState('declined');
    setTelemetryMessage('Telemetry disabled. No data will be sent.');
    setTimeout(() => setTelemetryMessage(null), 4000);
  }
}, [telemetryEnabled]);
```

**UI section (hardcoded English strings — per locked decision, consent/privacy text is always English):**

```tsx
{/* Privacy / Telemetry Section */}
<div className="pt-4 border-t border-outline">
  <div className="flex items-center justify-between">
    <div>
      <h4 className="text-sm font-medium text-on-surface-secondary">Privacy</h4>
      <p className="text-xs text-on-surface-muted">
        Anonymous usage data helps improve Ticketflow.
      </p>
    </div>
    <label className="relative inline-flex items-center cursor-pointer">
      <input
        type="checkbox"
        checked={telemetryEnabled}
        onChange={handleTelemetryToggle}
        className="sr-only peer"
      />
      <div className="w-11 h-6 bg-surface-alt rounded-full peer peer-checked:bg-accent peer-focus:ring-2 peer-focus:ring-accent/50 after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:after:translate-x-full" />
    </label>
  </div>
  {telemetryMessage && (
    <p className="mt-2 text-xs text-on-surface-muted px-3 py-1.5 rounded bg-surface-alt">
      {telemetryMessage}
    </p>
  )}
</div>
```

**Note:** The section label "Privacy" and the message "Telemetry disabled. No data will be sent." are hardcoded English strings. The description "Anonymous usage data helps improve Ticketflow." is also hardcoded English. This is per locked decision: consent/privacy text is always in English.

**Sync state on modal open:** Add to the existing `useEffect` that runs when `isOpen` changes, or add a new one:
```typescript
useEffect(() => {
  if (isOpen) {
    setTelemetryEnabled(getConsentState() === 'granted');
    setTelemetryMessage(null);
  }
}, [isOpen]);
```
This ensures the toggle reflects the current state when the modal is opened (in case consent changed elsewhere, e.g., from the consent dialog).
  </action>
  <verify>
`pnpm build` passes. AppSettingsModal shows a Privacy section with a toggle switch. Toggling off writes 'declined' to localStorage and shows confirmation message. Toggling on writes 'granted' and re-initializes telemetry.
  </verify>
  <done>
AppSettingsModal.tsx has a Privacy section with an on/off toggle. Disabling shows "Telemetry disabled. No data will be sent." confirmation. Enabling re-initializes telemetry. State syncs with localStorage on modal open.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes without errors
2. ConsentDialog.tsx has Accept and Decline buttons with identical class strings (equal weight)
3. ConsentDialog.tsx uses hardcoded English strings (no i18n imports)
4. App.tsx shows consent dialog only when consent is null and shouldPromptConsent() is true
5. App.tsx calls initTelemetry() and track('app_launched') when consent was previously granted
6. AppSettingsModal.tsx has a Privacy section with telemetry toggle
7. Toggling off in settings writes 'declined' to localStorage immediately
</verification>

<success_criteria>
- New users see a consent dialog before any telemetry fires
- Accept and Decline buttons have identical visual weight
- The consent dialog is always in English
- Dismissing re-prompts once, then treats as permanent Decline
- Users can toggle telemetry off in App Settings with immediate effect
- Toggling off shows confirmation message
</success_criteria>

<output>
After completion, create `.planning/phases/27-telemetry-core-consent/27-02-SUMMARY.md`
</output>
