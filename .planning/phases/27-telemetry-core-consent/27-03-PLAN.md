---
phase: 27-telemetry-core-consent
plan: "03"
type: execute
wave: 2
depends_on: ["27-01"]
files_modified:
  - src/components/workspace/ProjectWorkspace.tsx
  - src/components/kanban/KanbanBoard.tsx
  - src/components/palette/CommandPalette.tsx
  - src/components/import/BulkImportWizard.tsx
  - src/components/onboarding/OnboardingWizard.tsx
  - src/hooks/useGlobalShortcuts.ts
  - src/lib/ai.ts
  - src/lib/ai-health.ts
autonomous: true
requirements:
  - TELE-05
  - TELE-06

must_haves:
  truths:
    - "10 core events fire at the correct user action points (app_launched, project_created, ticket_created, ai_generation_completed, ai_generation_failed, view_switched, settings_opened, consent_granted, consent_revoked, project_opened)"
    - "5 secondary events fire at the correct action points (command_palette_opened, bulk_import_completed, onboarding_completed, dark_mode_toggled, ai_health_check_run)"
    - "Each event includes relevant context metadata (not just the event name)"
    - "No event fires in a render path — all events are in callbacks or lifecycle hooks"
  artifacts:
    - path: "src/components/workspace/ProjectWorkspace.tsx"
      provides: "project_opened, ticket_created, view_switched, settings_opened instrumentation"
      contains: "track("
    - path: "src/lib/ai.ts"
      provides: "ai_generation_completed, ai_generation_failed instrumentation"
      contains: "track("
    - path: "src/lib/ai-health.ts"
      provides: "ai_health_check_run instrumentation"
      contains: "track("
  key_links:
    - from: "src/components/workspace/ProjectWorkspace.tsx"
      to: "src/lib/telemetry.ts"
      via: "import { track } from '../../lib/telemetry'"
      pattern: "import.*track.*telemetry"
    - from: "src/lib/ai.ts"
      to: "src/lib/telemetry.ts"
      via: "import { track } from './telemetry'"
      pattern: "import.*track.*telemetry"
---

<objective>
Instrument all 15 core and secondary usage events across the codebase. Each event fires at the correct user action point with relevant context metadata. This delivers TELE-05 (10 core events) and TELE-06 (5 secondary events).

Purpose: Without instrumentation, the telemetry module is an empty pipe. This plan connects the pipe to the actual user interactions that matter for understanding app usage patterns.

Output: 8 modified files with `track()` calls at the correct action points.
</objective>

<execution_context>
@C:/Users/Boris/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Boris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/27-telemetry-core-consent/27-RESEARCH.md
@.planning/phases/27-telemetry-core-consent/27-01-SUMMARY.md
@src/lib/telemetry.ts
@src/components/workspace/ProjectWorkspace.tsx
@src/lib/ai.ts
@src/lib/ai-health.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Instrument core events in ProjectWorkspace, AI module, and settings</name>
  <files>src/components/workspace/ProjectWorkspace.tsx, src/lib/ai.ts, src/lib/ai-health.ts</files>
  <action>
Instrument the 10 core events from TELE-05. Import `import { track } from '../../lib/telemetry'` (or `'./telemetry'` for lib files) in each file.

**Event-by-event instrumentation guide:**

Note: `app_launched`, `consent_granted`, and `consent_revoked` are already handled by Plan 27-02 (in App.tsx and AppSettingsModal.tsx). This task handles the remaining 7 core events.

**1. `project_opened`** — in `ProjectWorkspace.tsx`
Location: Inside the component's initialization useEffect (there should be one that runs on mount with projectPath as dependency, or add a new one-time effect).
```typescript
useEffect(() => {
  track('project_opened', {
    has_items: items.length > 0,
    item_count: items.length,
  });
  // eslint-disable-next-line react-hooks/exhaustive-deps — fire once on mount only
}, []);
```
Note: This fires once when ProjectWorkspace mounts (per project). Since ProjectWorkspace is keyed by projectPath, it remounts on project change.
IMPORTANT: `items` may not be loaded yet on first render. Instead, fire this in a useEffect that depends on `backlog.isLoading`:
```typescript
const hasFiredProjectOpened = useRef(false);
useEffect(() => {
  if (!backlog.isLoading && !hasFiredProjectOpened.current) {
    hasFiredProjectOpened.current = true;
    track('project_opened', {
      has_items: items.length > 0,
      item_count: items.length,
    });
  }
}, [backlog.isLoading, items.length]);
```

**2. `project_created`** — in `ProjectWorkspace.tsx` or the component that handles project creation.
The project creation flow originates from WelcomePage. However, since ProjectWorkspace mounts immediately after project creation, and to avoid modifying too many files, use a simpler approach: check if this is a new project (0 items) on first mount and only fire `project_created` for genuinely new projects. Actually, project creation happens in `WelcomePage.tsx` — but that file is NOT in this plan's file list to minimize scope. Instead, since Plan 27-02 already modifies App.tsx, the `project_created` event should be fired from the project selection handler in App.tsx. BUT App.tsx is owned by Plan 27-02.

**RESOLUTION:** Fire `project_created` from `ProjectWorkspace.tsx` on first mount IF item_count === 0 AND the project was just created (no existing sections). This is a reasonable heuristic. Add a check: if `items.length === 0` and `backlog.sections.length <= 0` on first mount, fire project_created.

Alternatively, if this is too heuristic-heavy, the simpler approach is: the WelcomePage calls `track('project_created')` after a project is created. Since WelcomePage is imported in App.tsx but is a separate file, add it there:

Add to `src/components/welcome/WelcomePage.tsx` (add this file to the files list for this task) — NO, that adds another file and WelcomePage has complex logic. Keep it simple: fire `project_created` from ProjectWorkspace on mount when item count is 0. This is an acceptable approximation.

```typescript
// In the hasFiredProjectOpened effect:
if (items.length === 0) {
  track('project_created');
}
```

**3. `ticket_created`** — in `ProjectWorkspace.tsx`
Location: Inside the `handleCreateItem` (or equivalent) callback, AFTER the item is successfully created/saved.
```typescript
track('ticket_created', {
  type: newItem.typeId,
  via: 'editor', // or 'ai' / 'quick_capture' depending on origin
});
```
Look for the function that handles saving a new item from the editor modal. Add `track()` after the DB insert succeeds. The `via` property should be 'editor' for manual creation. If the item was AI-generated, the AI module will fire `ai_generation_completed` separately — the `ticket_created` event just tracks that a ticket was persisted.

**4. `ai_generation_completed`** — in `src/lib/ai.ts`
Location: After a successful AI generation returns. Look for the function that calls the AI provider and returns the generated item(s). Add after the response is successfully parsed:
```typescript
track('ai_generation_completed', {
  provider: getProvider(), // or the provider name from config
  type: 'ticket', // or 'refinement' or 'bulk' depending on the function
});
```
The `getProvider()` function already exists in ai.ts. Use it to get the current provider name.

**5. `ai_generation_failed`** — in `src/lib/ai.ts`
Location: In the catch block of AI generation. Use the error classification from ai-health.ts if available, otherwise use generic error type:
```typescript
track('ai_generation_failed', {
  provider: getProvider(),
  type: 'ticket',
  error_type: 'unknown', // classify if possible: 'auth' | 'rate_limit' | 'timeout' | 'network' | 'unknown'
});
```

**6. `view_switched`** — in `ProjectWorkspace.tsx`
Location: In the view mode switching handler (setViewMode or equivalent). Fire when the user changes between kanban/list/graph/dashboard/archive views:
```typescript
// Find where viewMode is changed and add:
track('view_switched', { to: newViewMode });
```
Look for the `setViewMode` call or the view tab click handler.

**7. `settings_opened`** — in `ProjectWorkspace.tsx`
Location: In the callbacks that open settings modals. There are multiple: onOpenSettings (app), onOpenAISettings (AI), onOpenTypeConfig, onOpenProjectSettings. Fire the event in each handler passed as props or where they're called:
```typescript
// For each settings open callback, add:
track('settings_opened', { panel: 'app' }); // or 'ai', 'type_config', 'project'
```
Since these callbacks come from App.tsx props, the simplest approach is to wrap them in ProjectWorkspace where they're used. Look for where `onOpenSettings()` is called (e.g., in the Header component callback) and add track() alongside it.

Actually, the settings handlers are passed as props from App.tsx. The cleanest place to instrument is where ProjectWorkspace calls them. Find the callback wiring in ProjectWorkspace (e.g., `openSettings: onOpenSettings` in the workspace actions) and wrap them:
```typescript
const handleOpenSettings = useCallback(() => {
  track('settings_opened', { panel: 'app' });
  onOpenSettings();
}, [onOpenSettings]);
```
Apply the same pattern for AI settings, type config, project settings.

**8. `ai_health_check_run`** — in `src/lib/ai-health.ts`
Location: At the end of the health check function (after the check completes), fire:
```typescript
import { track } from './telemetry';

// At the end of checkProviderHealth (or equivalent function), after getting the result:
track('ai_health_check_run', {
  provider: providerName,
  success: result.ok, // or result.status === 'ok'
  latency_ms: result.latencyMs, // if available
});
```
  </action>
  <verify>
`pnpm build` passes. `grep -r "track(" src/components/workspace/ProjectWorkspace.tsx src/lib/ai.ts src/lib/ai-health.ts` returns multiple matches. Each track() call is inside a callback or effect, never in the render body.
  </verify>
  <done>
7 of 10 core events are instrumented at their correct action points (project_opened, project_created, ticket_created, ai_generation_completed, ai_generation_failed, view_switched, settings_opened). The remaining 3 (app_launched, consent_granted, consent_revoked) are handled by Plan 27-02. ai_health_check_run is instrumented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Instrument secondary events across UI components</name>
  <files>src/components/palette/CommandPalette.tsx, src/components/import/BulkImportWizard.tsx, src/components/onboarding/OnboardingWizard.tsx, src/hooks/useGlobalShortcuts.ts</files>
  <action>
Instrument the 5 secondary events from TELE-06. Import `import { track } from '../../lib/telemetry'` (adjust path as needed) in each file.

**1. `command_palette_opened`** — in `CommandPalette.tsx`
Location: In the effect or handler that runs when the palette opens (e.g., when isOpen becomes true, or in the open handler):
```typescript
useEffect(() => {
  if (isOpen) {
    track('command_palette_opened');
  }
}, [isOpen]);
```
Only fire when the palette opens, not on every render.

**2. `bulk_import_completed`** — in `BulkImportWizard.tsx`
Location: In the final step's completion handler, after items are successfully imported:
```typescript
track('bulk_import_completed', {
  items_imported: importedItems.length, // or the count of imported items
});
```
Look for the "finish" or "complete" handler in the wizard's final step.

**3. `onboarding_completed`** — in `OnboardingWizard.tsx`
Location: In the `onComplete` handler or the final step's "Get Started" button handler:
```typescript
track('onboarding_completed', {
  steps_completed: totalSteps, // or the number of steps the user went through
  ai_configured: hasConfiguredAI, // boolean if AI was set up during onboarding
});
```
Look for where `onComplete()` is called and add the track() before it.

**4. `dark_mode_toggled`** — in `AppSettingsModal.tsx`
Wait — AppSettingsModal.tsx is owned by Plan 27-02 (files_modified includes it). So this event CANNOT be added here without creating a file conflict.

**RESOLUTION:** The `dark_mode_toggled` event should fire from where the theme is actually changed. Look at the theme toggle in AppSettingsModal — it calls `setTheme(opt.value)`. Since AppSettingsModal.tsx is owned by 27-02, add `dark_mode_toggled` in that plan instead. For this task, skip it and add a note.

ACTUALLY — re-reading the dependency graph: 27-02 and 27-03 are both Wave 2 and touch different files. 27-02 owns AppSettingsModal.tsx. So `dark_mode_toggled` MUST be added by 27-02, not 27-03.

Alternative: Fire `dark_mode_toggled` from the theme hook (`useTheme`) or from `useGlobalShortcuts.ts` if there's a keyboard shortcut for dark mode. Check if there's a dark mode shortcut in shortcuts.ts.

Better approach: Add `dark_mode_toggled` to `src/hooks/useGlobalShortcuts.ts` IF there's a dark mode shortcut, OR add it to a wrapper in ProjectWorkspace where theme changes are detected. Since this is a secondary event and AppSettingsModal is owned by 27-02, the simplest solution is: **have Plan 27-02 add `dark_mode_toggled` alongside the Privacy section changes.** Add a clear note in this plan that `dark_mode_toggled` is delegated to Plan 27-02 since it owns AppSettingsModal.tsx.

For this task, instrument the remaining 4 secondary events.

**5. `ai_health_check_run`** — already handled in Task 1 (src/lib/ai-health.ts). Skip here.

**So this task handles: command_palette_opened, bulk_import_completed, onboarding_completed.**

For each file:
- Import `track` from the telemetry module
- Add the track() call at the correct action point
- Ensure track() is in a callback/effect, never in a render path
- Include relevant context metadata

**BulkImportWizard.tsx** — look for the final import completion handler. It likely calls a function to persist the imported items. Add track() after the success callback fires. Use the count of items that were actually imported (not the total parsed).

**OnboardingWizard.tsx** — look for the complete/finish handler. The wizard has 7 steps. Track how many the user completed and whether AI was configured. Look for a state variable tracking AI setup completion.

**CommandPalette.tsx** — the simplest: fire when the palette opens. Use a useEffect watching the `isOpen` prop.
  </action>
  <verify>
`pnpm build` passes. `grep -r "track(" src/components/palette/CommandPalette.tsx src/components/import/BulkImportWizard.tsx src/components/onboarding/OnboardingWizard.tsx` returns at least one match per file.
  </verify>
  <done>
3 secondary events are instrumented (command_palette_opened, bulk_import_completed, onboarding_completed). dark_mode_toggled is delegated to Plan 27-02 (which owns AppSettingsModal.tsx). ai_health_check_run was handled in Task 1.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes without errors
2. All 15 events are accounted for:
   - app_launched: Plan 27-02 (App.tsx)
   - consent_granted: Plan 27-02 (App.tsx + AppSettingsModal)
   - consent_revoked: Plan 27-02 (AppSettingsModal)
   - project_opened: This plan (ProjectWorkspace)
   - project_created: This plan (ProjectWorkspace)
   - ticket_created: This plan (ProjectWorkspace)
   - ai_generation_completed: This plan (ai.ts)
   - ai_generation_failed: This plan (ai.ts)
   - view_switched: This plan (ProjectWorkspace)
   - settings_opened: This plan (ProjectWorkspace)
   - command_palette_opened: This plan (CommandPalette.tsx)
   - bulk_import_completed: This plan (BulkImportWizard.tsx)
   - onboarding_completed: This plan (OnboardingWizard.tsx)
   - dark_mode_toggled: Plan 27-02 (AppSettingsModal.tsx)
   - ai_health_check_run: This plan (ai-health.ts)
3. No track() call appears in a React render body (only in callbacks, effects, or event handlers)
4. `pnpm test` passes (445+ tests, zero new failures)
</verification>

<success_criteria>
- All 15 usage events from TELE-05 and TELE-06 are instrumented
- Each event fires at the correct user interaction point with context metadata
- No telemetry code in render paths (only callbacks/effects)
- pnpm build and pnpm test pass without regressions
</success_criteria>

<output>
After completion, create `.planning/phases/27-telemetry-core-consent/27-03-SUMMARY.md`
</output>
