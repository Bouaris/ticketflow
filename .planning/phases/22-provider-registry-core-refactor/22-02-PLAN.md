---
phase: 22-provider-registry-core-refactor
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - src/lib/ai.ts
  - src/lib/ai-retry.ts
  - src/constants/storage.ts
  - src/constants/config.ts
autonomous: true

must_haves:
  truths:
    - "OpenAI-compatible clients are created with baseURL from registry (not hardcoded)"
    - "Switching between two custom providers with different baseURLs creates distinct client instances (no state leaks)"
    - "Built-in providers (Groq, Gemini, OpenAI) continue to work exactly as before"
    - "getEffectiveAIConfig returns global provider config without project-level override logic"
    - "resetClient can clear a specific provider's cache by ID or all caches"
    - "generateCompletion routes openai-compatible custom providers through OpenAI SDK with correct baseURL"
  artifacts:
    - path: "src/lib/ai.ts"
      provides: "Registry-integrated AI client with expanded singleton cache"
      exports: ["AIProvider", "getProvider", "getApiKey", "setApiKey", "generateCompletion", "resetClient", "getEffectiveAIConfig"]
    - path: "src/lib/ai-retry.ts"
      provides: "Structured output detection using registry provider types"
      exports: ["getStructuredOutputMode"]
    - path: "src/constants/storage.ts"
      provides: "Storage keys for custom provider API keys"
      contains: "CUSTOM_AI_PROVIDERS"
    - path: "src/constants/config.ts"
      provides: "AI config with model defaults sourced from registry"
  key_links:
    - from: "src/lib/ai.ts"
      to: "src/lib/ai-provider-registry.ts"
      via: "import getProviderById, getAllProviders"
      pattern: "import.*from.*ai-provider-registry"
    - from: "src/lib/ai.ts"
      to: "OpenAI SDK"
      via: "getOpenAIClient with baseURL param"
      pattern: "new OpenAI\\(\\{.*baseURL"
    - from: "src/lib/ai-retry.ts"
      to: "src/lib/ai-provider-registry.ts"
      via: "import for provider type resolution"
      pattern: "import.*from.*ai-provider-registry"
---

<objective>
Refactor the core AI client module to use the provider registry, expand singleton cache keys to include baseURL, and simplify getEffectiveAIConfig to use global-only config.

Purpose: Replace scattered hardcoded provider logic with registry lookups, prevent state leaks when switching between custom providers, and remove project-level AI config resolution.

Output: Updated `src/lib/ai.ts`, `src/lib/ai-retry.ts`, `src/constants/storage.ts`, `src/constants/config.ts`
</objective>

<execution_context>
@C:/Users/Boris/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Boris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-provider-registry-core-refactor/22-RESEARCH.md
@.planning/phases/22-provider-registry-core-refactor/22-01-SUMMARY.md
@src/lib/ai.ts
@src/lib/ai-retry.ts
@src/constants/storage.ts
@src/constants/config.ts
@src/types/aiProvider.ts
@src/lib/ai-provider-registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand singleton cache and integrate registry in ai.ts</name>
  <files>src/lib/ai.ts, src/constants/storage.ts, src/constants/config.ts</files>
  <action>
**A. Update `src/constants/storage.ts`:**

Add a new storage key for custom provider API keys:
```typescript
CUSTOM_AI_PROVIDERS: 'custom-ai-providers',
CUSTOM_PROVIDER_API_KEY_PREFIX: 'custom-provider-api-key',
```

Add a helper function:
```typescript
export function getCustomProviderApiKeyKey(providerId: string): string {
  return `${STORAGE_KEYS.CUSTOM_PROVIDER_API_KEY_PREFIX}-${providerId}`;
}
```

**B. Update `src/constants/config.ts`:**

No structural changes needed. The `AI_CONFIG` constants (GROQ_MODEL, GEMINI_MODEL, OPENAI_MODEL) stay as-is for backward compatibility. They serve as fallback defaults. The registry is the source of truth for model lists, but these constants remain for the `generateCompletion` default model resolution.

**C. Refactor `src/lib/ai.ts`:**

1. **Add imports** from registry:
   ```typescript
   import { getProviderById, isBuiltInProvider, getBuiltInProvider } from './ai-provider-registry';
   import type { ProviderConfig, BuiltInProviderId } from '../types/aiProvider';
   import { getCustomProviderApiKeyKey } from '../constants/storage';
   ```

2. **Keep `AIProvider` type** as `'groq' | 'gemini' | 'openai'` for backward compatibility. Add a new type:
   ```typescript
   /** Extended provider ID that includes custom provider IDs */
   export type ProviderId = string;
   ```

3. **Expand OpenAI client singleton to Map-based cache**:

   Replace the current single `openaiClient` / `openaiClientKey` pattern with:
   ```typescript
   // Groq and Gemini keep simple singleton (one instance each, keyed by apiKey)
   let groqClient: Groq | null = null;
   let groqClientKey: string | null = null;
   let geminiClient: GoogleGenerativeAI | null = null;
   let geminiClientKey: string | null = null;

   // OpenAI-compatible clients: Map-based cache keyed by "apiKey::baseURL"
   const openaiClientCache = new Map<string, OpenAI>();

   function getOpenAICacheKey(apiKey: string, baseURL?: string): string {
     return baseURL ? `${apiKey}::${baseURL}` : apiKey;
   }
   ```

   Update `getOpenAIClient` to accept optional `baseURL`:
   ```typescript
   function getOpenAIClient(apiKey: string, baseURL?: string): OpenAI {
     const cacheKey = getOpenAICacheKey(apiKey, baseURL);
     if (!openaiClientCache.has(cacheKey)) {
       openaiClientCache.set(cacheKey, new OpenAI({
         apiKey,
         ...(baseURL && { baseURL }),
         dangerouslyAllowBrowser: true,
       }));
     }
     return openaiClientCache.get(cacheKey)!;
   }
   ```

4. **Update `resetClient`** to support targeted clearing:
   ```typescript
   export function resetClient(providerId?: string): void {
     if (!providerId) {
       // Clear all caches
       groqClient = null;
       geminiClient = null;
       openaiClientCache.clear();
       groqClientKey = null;
       geminiClientKey = null;
       return;
     }

     if (providerId === 'groq') {
       groqClient = null;
       groqClientKey = null;
     } else if (providerId === 'gemini') {
       geminiClient = null;
       geminiClientKey = null;
     } else {
       // Clear specific openai-compatible provider entries
       // For built-in openai, clear entries without custom baseURL
       // For custom providers, clear entries matching their baseURL
       const providerConfig = getProviderById(providerId);
       if (providerConfig) {
         for (const [key] of openaiClientCache) {
           if (providerConfig.baseURL && key.endsWith(`::${providerConfig.baseURL}`)) {
             openaiClientCache.delete(key);
           } else if (!providerConfig.baseURL && !key.includes('::')) {
             openaiClientCache.delete(key);
           }
         }
       } else {
         // Unknown provider — clear all openai cache as safety measure
         openaiClientCache.clear();
       }
     }
   }
   ```

5. **Update `getApiKeyStorageKey`** to support custom providers:
   ```typescript
   function getApiKeyStorageKey(provider: string): string {
     switch (provider) {
       case 'groq': return STORAGE_KEYS.GROQ_API_KEY;
       case 'gemini': return STORAGE_KEYS.GEMINI_API_KEY;
       case 'openai': return STORAGE_KEYS.OPENAI_API_KEY;
       default: return getCustomProviderApiKeyKey(provider);
     }
   }
   ```

   Update function signatures for `getApiKey`, `setApiKey`, `clearApiKey`, `hasApiKey` to accept `string` (not just `AIProvider`):
   ```typescript
   export function getApiKey(provider?: string): string | null {
     const p = provider || getProvider();
     return getSecureItem(getApiKeyStorageKey(p));
   }
   ```
   Same pattern for `setApiKey`, `clearApiKey`, `hasApiKey`.

6. **Update `getClientConfig`** to accept string provider ID:
   ```typescript
   export function getClientConfig(overrideProvider?: string): AIClientConfig | null {
     const provider = overrideProvider || getProvider();
     const apiKey = getApiKey(provider);
     if (!apiKey) return null;
     return { provider: provider as AIProvider, apiKey };
   }
   ```

7. **Simplify `getEffectiveAIConfig`** — remove project-level config resolution:
   ```typescript
   export function getEffectiveAIConfig(_projectPath?: string): {
     provider: AIProvider;
     modelId: string;
   } {
     // Global settings only (project-level config removed per v2.1 decision)
     const globalProvider = getProvider();
     const providerConfig = getProviderById(globalProvider);
     const defaultModel = providerConfig?.defaultModel
       ?? (globalProvider === 'groq' ? AI_CONFIG.GROQ_MODEL
         : globalProvider === 'gemini' ? AI_CONFIG.GEMINI_MODEL
         : AI_CONFIG.OPENAI_MODEL);

     return {
       provider: globalProvider,
       modelId: defaultModel,
     };
   }
   ```

   Keep the `_projectPath` parameter with underscore prefix for backward compatibility (callers still pass it, but it's ignored). Add a JSDoc comment: `@deprecated projectPath parameter is ignored — global config only since v2.1`.

8. **Update `getProviderDisplayName`** to use registry:
   ```typescript
   export function getProviderDisplayName(provider: string): string {
     const config = getProviderById(provider);
     if (config) return config.name;
     // Fallback for unknown providers
     return provider.charAt(0).toUpperCase() + provider.slice(1);
   }
   ```

9. **Update `generateCompletion`** to route custom openai-compatible providers:

   In the provider routing logic, replace the hardcoded `config.provider === 'groq'` / `=== 'gemini'` / `else` pattern with a registry-aware approach:

   ```typescript
   async function generateCompletion(prompt: string, options?: CompletionOptions): Promise<string> {
     const providerId = options?.provider || getProvider();
     const clientConfig = getClientConfig(providerId);
     if (!clientConfig) {
       const t = getTranslations();
       throw new Error(`${getProviderDisplayName(providerId)} ${t.aiErrors.apiKeyNotConfigured}`);
     }

     // Resolve provider type from registry
     const providerDef = getProviderById(providerId);
     const providerType = providerDef?.type ?? providerId; // fallback to ID as type for built-ins

     const modelId = options?.modelId || (
       providerDef?.defaultModel
       ?? (providerId === 'groq' ? AI_CONFIG.GROQ_MODEL
         : providerId === 'gemini' ? AI_CONFIG.GEMINI_MODEL
         : AI_CONFIG.OPENAI_MODEL)
     );

     // ... structured output detection stays the same ...

     if (providerType === 'groq') {
       // ... existing Groq logic unchanged ...
     } else if (providerType === 'gemini') {
       // ... existing Gemini logic unchanged ...
     } else {
       // OpenAI-compatible (built-in OpenAI + all custom providers)
       const client = getOpenAIClient(clientConfig.apiKey, providerDef?.baseURL);
       // ... rest of OpenAI logic unchanged, using client ...
     }
   }
   ```

   Apply the same pattern to `generateChatCompletion`.

10. **Remove project-level AI config functions** — Delete `loadProjectAIConfig` and `saveProjectAIConfig` functions. Remove the import of `ProjectAIConfigSchema`, `DEFAULT_PROJECT_AI_CONFIG`, `DEFAULT_MODELS` from `projectAIConfig.ts`. Remove the import of `getProjectAIConfigKey` from storage constants.

    **IMPORTANT**: Keep the re-exports and type exports intact for now. The `AIProvider` type stays exported. Add deprecation comments where appropriate.

11. **Update `initSecureStorage`** — no changes needed, it only handles built-in provider keys.
  </action>
  <verify>
`pnpm build` passes without errors. Verify:
- `resetClient()` clears all caches, `resetClient('groq')` clears only Groq
- `getEffectiveAIConfig()` returns global provider without project path resolution
- `getOpenAIClient('key', 'https://custom.example.com/v1')` creates a distinct instance from `getOpenAIClient('key')`
  </verify>
  <done>
ai.ts uses registry for provider lookups, OpenAI-compatible clients are Map-cached by apiKey+baseURL, project-level AI config removed, all existing exports maintained for backward compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ai-retry.ts to support custom provider structured output detection</name>
  <files>src/lib/ai-retry.ts</files>
  <action>
Update `getStructuredOutputMode` in `ai-retry.ts` to handle custom providers:

1. **Add import** from registry:
   ```typescript
   import { getProviderById } from './ai-provider-registry';
   ```

2. **Update `getStructuredOutputMode` function** (currently accepts `provider: 'groq' | 'gemini' | 'openai'`):

   Change parameter type to `string` to accept custom provider IDs:
   ```typescript
   export function getStructuredOutputMode(provider: string, modelId: string): StructuredOutputMode {
     // Resolve provider type from registry
     const providerConfig = getProviderById(provider);
     const providerType = providerConfig?.type ?? provider;

     if (providerType === 'groq') {
       // ... existing groq logic ...
     } else if (providerType === 'openai-compatible') {
       // For custom openai-compatible providers, use conservative 'none'
       // unless the model is known to support structured output
       if (providerConfig?.isCustom) {
         return 'none'; // Conservative: custom providers may not support structured output
       }
       // Built-in OpenAI check
       if (STRUCTURED_OUTPUT_SUPPORT.openai.strict.includes(modelId)) return 'strict';
       return 'none';
     } else if (providerType === 'gemini') {
       // ... existing gemini logic ...
     }

     return 'none';
   }
   ```

   This ensures:
   - Built-in providers keep exact same behavior
   - Custom openai-compatible providers default to 'none' (safe fallback — no structured output assumption for unknown endpoints)
   - The function gracefully handles unknown provider types

3. **Update `StructuredOutputSupport` interface** if needed to accommodate the provider type changes. The existing interface uses 'groq', 'openai', 'gemini' keys — keep these as-is since they map to provider types, not IDs.
  </action>
  <verify>
`pnpm build` passes. `getStructuredOutputMode('groq', 'llama-3.3-70b-versatile')` returns 'bestEffort' (unchanged). `getStructuredOutputMode('custom-ollama', 'llama3')` returns 'none'.
  </verify>
  <done>
ai-retry.ts `getStructuredOutputMode` accepts arbitrary provider IDs, resolves to provider type via registry, and returns conservative 'none' for custom providers.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes without errors
2. Existing AI generation still works with built-in providers (Groq, Gemini, OpenAI)
3. OpenAI-compatible custom providers route through OpenAI SDK with correct baseURL
4. Singleton cache correctly separates clients by apiKey + baseURL
5. `getEffectiveAIConfig()` ignores projectPath parameter
6. `getStructuredOutputMode` returns 'none' for custom providers
7. No dead code (removed project AI config functions, cleaned imports)
</verification>

<success_criteria>
- ai.ts compiles with registry imports and Map-based OpenAI client cache
- Custom providers with different baseURLs get distinct OpenAI client instances
- getEffectiveAIConfig simplified to global-only (projectPath ignored)
- ai-retry handles custom provider types with conservative structured output defaults
- Zero regression for built-in provider usage
</success_criteria>

<output>
After completion, create `.planning/phases/22-provider-registry-core-refactor/22-02-SUMMARY.md`
</output>
