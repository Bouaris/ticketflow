---
phase: 25-model-resolution-selection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/constants/storage.ts
  - src/lib/ai.ts
  - src/lib/ai-dependencies.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "When user overrides provider in ticket creation, the correct model for that provider is sent to the API"
    - "getEffectiveAIConfig reads persisted model choice from localStorage when available"
    - "All 8 affected functions resolve model from the overridden provider, not the global provider"
  artifacts:
    - path: "src/constants/storage.ts"
      provides: "AI_MODEL_PREFIX storage key and getModelStorageKey helper"
      contains: "AI_MODEL_PREFIX"
    - path: "src/lib/ai.ts"
      provides: "getSelectedModel, setSelectedModel helpers and fixed getEffectiveAIConfig"
      exports: ["getSelectedModel", "setSelectedModel"]
    - path: "src/lib/ai-dependencies.ts"
      provides: "Fixed detectDependencies model resolution"
      contains: "resolveModelForProvider"
  key_links:
    - from: "src/lib/ai.ts"
      to: "src/constants/storage.ts"
      via: "getModelStorageKey import"
      pattern: "getModelStorageKey"
    - from: "src/lib/ai.ts"
      to: "src/lib/ai-provider-registry.ts"
      via: "getProviderById for model resolution"
      pattern: "getProviderById\\(effectiveProvider\\)"
---

<objective>
Fix provider override model resolution (GENX-03) and add model persistence infrastructure.

Purpose: When a user selects a different provider in ticket creation (e.g., switches from Gemini to Groq), the API call currently sends the wrong model ID (e.g., `gemini-2.0-flash` to the Groq API, causing a 404). This plan fixes all 8 affected functions to resolve the model from the overridden provider's registry entry, and adds localStorage persistence for user model selection.

Output: Fixed model resolution in ai.ts and ai-dependencies.ts, new storage key + helpers for model persistence.
</objective>

<execution_context>
@C:/Users/Boris/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Boris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-model-resolution-selection/25-RESEARCH.md

@src/constants/storage.ts
@src/lib/ai.ts
@src/lib/ai-dependencies.ts
@src/lib/ai-provider-registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add model storage key and persistence helpers</name>
  <files>src/constants/storage.ts, src/lib/ai.ts</files>
  <action>
**In `src/constants/storage.ts`:**

1. Add `AI_MODEL_PREFIX: 'ai-model'` to the `STORAGE_KEYS` object (after `CUSTOM_PROVIDER_API_KEY_PREFIX`).

2. Add a new helper function after `getCustomProviderApiKeyKey`:

```typescript
/**
 * Build a storage key for a provider's selected model
 */
export function getModelStorageKey(providerId: string): string {
  return `${STORAGE_KEYS.AI_MODEL_PREFIX}-${providerId}`;
}
```

**In `src/lib/ai.ts`:**

3. Add import of `getModelStorageKey` from `../../constants/storage` (the file already imports `STORAGE_KEYS` from there, add `getModelStorageKey` to the same import).

4. Add two new exported functions right before `getEffectiveAIConfig` (around line 240):

```typescript
/**
 * Get user's selected model for a provider from localStorage.
 * Returns null if no selection persisted (use provider default).
 */
export function getSelectedModel(providerId: string): string | null {
  return localStorage.getItem(getModelStorageKey(providerId));
}

/**
 * Persist user's selected model for a provider.
 */
export function setSelectedModel(providerId: string, modelId: string): void {
  localStorage.setItem(getModelStorageKey(providerId), modelId);
}
```

5. Update `getEffectiveAIConfig` to read the persisted model choice. Replace the current implementation (lines 247-262) with:

```typescript
export function getEffectiveAIConfig(_projectPath?: string): {
  provider: AIProvider;
  modelId: string;
} {
  const globalProvider = getProvider();
  const providerConfig = getProviderById(globalProvider);

  // Read persisted model selection, falling back to provider default
  const selectedModel = getSelectedModel(globalProvider);
  const defaultModel = providerConfig?.defaultModel
    ?? (globalProvider === 'groq' ? AI_CONFIG.GROQ_MODEL
      : globalProvider === 'gemini' ? AI_CONFIG.GEMINI_MODEL
      : AI_CONFIG.OPENAI_MODEL);

  return {
    provider: globalProvider,
    modelId: selectedModel || defaultModel,
  };
}
```

6. Add a new helper function `resolveModelForProvider` right after `getEffectiveAIConfig`:

```typescript
/**
 * Resolve the correct model ID for a given provider.
 * Uses: persisted user selection > provider's defaultModel > hardcoded fallback.
 * This is the authoritative model resolution — use when provider may be overridden.
 */
export function resolveModelForProvider(providerId: string): string {
  const selected = getSelectedModel(providerId);
  if (selected) return selected;

  const providerConfig = getProviderById(providerId);
  if (providerConfig?.defaultModel) return providerConfig.defaultModel;

  // Ultimate fallback for unknown/deleted providers
  if (providerId === 'groq') return AI_CONFIG.GROQ_MODEL;
  if (providerId === 'gemini') return AI_CONFIG.GEMINI_MODEL;
  return AI_CONFIG.OPENAI_MODEL;
}
```

This provides the infrastructure needed by both this plan (Task 2) and Plan 02 (model dropdown UI).
  </action>
  <verify>Run `pnpm build` — must compile with no TypeScript errors. Verify `getSelectedModel`, `setSelectedModel`, `resolveModelForProvider` are exported from ai.ts. Verify `getModelStorageKey` is exported from storage.ts.</verify>
  <done>Storage key `AI_MODEL_PREFIX` exists in STORAGE_KEYS. Three new functions exported from ai.ts. getEffectiveAIConfig reads persisted model. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Fix model resolution in all 8 affected functions</name>
  <files>src/lib/ai.ts, src/lib/ai-dependencies.ts</files>
  <action>
Fix all 8 functions that destructure `{ provider, modelId }` from `getEffectiveAIConfig` and then override the provider but NOT the model. In each case, replace the pattern:

```typescript
// BEFORE (broken):
const { provider, modelId } = getEffectiveAIConfig(options?.projectPath);
const effectiveProvider = options?.provider || provider;
// ... later uses modelId (which is wrong when provider is overridden)
```

With:

```typescript
// AFTER (fixed):
const { provider } = getEffectiveAIConfig(options?.projectPath);
const effectiveProvider = options?.provider || provider;
const modelId = options?.modelId || resolveModelForProvider(effectiveProvider);
```

**Apply this fix in all 8 locations:**

**In `src/lib/ai.ts`:**

1. **`generateItemFromDescription`** (~line 1183-1184): Replace the destructuring and add `resolveModelForProvider(effectiveProvider)`. The `modelId` variable is used later at ~line 1234 in the `generateCompletionWithRetry` call.

2. **`refineItem`** (~line 811-812): Same pattern. `modelId` is used in the `generateCompletionWithRetry` call further down.

3. **`suggestImprovements`** (~line 1347-1348): Same pattern. `modelId` is used at ~line 1363.

4. **`analyzeBacklogFormat`** (~line 1646-1647): Same pattern. `modelId` is used at ~line 1657 in `generateCompletion` call.

5. **`correctBacklogFormat`** (~line 1698-1699): Same pattern. `modelId` is used at ~line 1716 in `generateCompletion` call.

6. **`analyzeBacklog` (main body)** (~line 2015-2016): Same pattern. `modelId` is used at ~line 2058 in `generateCompletion` call.

7. **`analyzeBacklog` (catch/telemetry block)** (~line 2143-2144): Same pattern. This is in the catch block for telemetry recording — model resolution should still be correct for error tracking.

**In `src/lib/ai-dependencies.ts`:**

8. **`detectDependencies` (main body)** (~line 194-195): Same pattern. `modelId` is used at ~line 204.

9. **`detectDependencies` (catch/telemetry block)** (~line 244-245): Same pattern. Used for error telemetry.

**Important:** `resolveModelForProvider` is defined in `ai.ts`. In `ai-dependencies.ts`, import it:
```typescript
import { resolveModelForProvider } from './ai';
```
Add this to the existing imports from `./ai` in ai-dependencies.ts. Check the current imports at the top of the file and add `resolveModelForProvider` to the existing import statement.

**Do NOT modify:**
- `generateCompletion` itself — its internal model resolution is already correct (it's a good fallback)
- `CompletionOptions` type — `modelId` field already exists
- Any function that does NOT override the provider (i.e., functions that just use `getEffectiveAIConfig` result directly without `options?.provider` override)
  </action>
  <verify>Run `pnpm build` — must compile with no TypeScript errors. Grep for the old broken pattern `const { provider, modelId } = getEffectiveAIConfig` — should return ZERO results. Grep for `resolveModelForProvider(effectiveProvider)` — should return 9 results (8 call sites + 1 definition).</verify>
  <done>All 8 affected functions resolve model from the overridden provider. No function uses the global provider's model when a different provider is selected. Build passes. Old broken destructuring pattern eliminated.</done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with zero errors
2. `grep -r "const { provider, modelId } = getEffectiveAIConfig" src/` returns zero matches
3. `grep -r "resolveModelForProvider" src/` returns matches in ai.ts (definition + 7 usages) and ai-dependencies.ts (2 usages)
4. `getSelectedModel`, `setSelectedModel`, `resolveModelForProvider` are all exported from ai.ts
5. `getModelStorageKey` is exported from storage.ts
6. No unused imports or variables
</verification>

<success_criteria>
- GENX-03 gap is closed: provider override in ticket creation correctly resolves the model for the overridden provider
- Model persistence infrastructure exists (getSelectedModel/setSelectedModel) for Plan 02 to consume
- getEffectiveAIConfig returns persisted model when available
- All 8 previously broken call sites use resolveModelForProvider
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/25-model-resolution-selection/25-01-SUMMARY.md`
</output>
