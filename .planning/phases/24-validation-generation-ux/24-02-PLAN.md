---
phase: 24-validation-generation-ux
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ai.ts
autonomous: true

must_haves:
  truths:
    - "generateCompletion accepts an optional AbortSignal and passes it through to all 3 SDK clients (Groq, Gemini, OpenAI)"
    - "generateChatCompletion accepts an optional AbortSignal and passes it through to all 3 SDK clients"
    - "generateCompletionWithRetry propagates signal through to generateCompletion"
    - "CompletionOptions and ChatCompletionOptions interfaces include optional signal field"
    - "Existing callers continue to work without providing signal (backward compatible)"
  artifacts:
    - path: "src/lib/ai.ts"
      provides: "Signal propagation for all AI completion functions"
      contains: "signal?: AbortSignal"
  key_links:
    - from: "src/lib/ai.ts CompletionOptions"
      to: "Groq SDK client.chat.completions.create"
      via: "signal option passed to SDK create call"
      pattern: "signal.*options.*signal"
    - from: "src/lib/ai.ts CompletionOptions"
      to: "Google GenerativeAI model.generateContent"
      via: "requestOptions with signal"
      pattern: "signal"
    - from: "src/lib/ai.ts CompletionOptions"
      to: "OpenAI SDK client.chat.completions.create"
      via: "signal option passed to SDK create call"
      pattern: "signal.*options.*signal"
---

<objective>
Add AbortSignal propagation through the entire AI completion stack. This is the foundational change that enables user cancellation of in-flight AI operations.

Purpose: Wire the `signal` parameter from component layer through `generateCompletion`, `generateChatCompletion`, and `generateCompletionWithRetry` down to the actual SDK HTTP calls. This unblocks Plan 03's cancel button and progress UI.

Output: Updated `src/lib/ai.ts` with signal support in all completion paths
</objective>

<execution_context>
@C:/Users/Boris/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Boris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-validation-generation-ux/24-RESEARCH.md
@src/lib/ai.ts
@src/lib/abort.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add signal parameter to CompletionOptions and wire through generateCompletion</name>
  <files>src/lib/ai.ts</files>
  <action>
Modify `src/lib/ai.ts` to support AbortSignal propagation through all AI completion functions.

**1. Update `CompletionOptions` interface** (around line 277):
Add `signal?: AbortSignal;` field:
```typescript
interface CompletionOptions {
  provider?: string;
  modelId?: string;
  schema?: ZodType;
  images?: ImageData[];
  maxTokens?: number;
  signal?: AbortSignal;  // NEW: Enable cancellation of in-flight requests
}
```

**2. Update `generateCompletion` function** to pass signal to each SDK:

For Groq provider (around line 341):
```typescript
const response = await client.chat.completions.create(request);
```
Change to:
```typescript
const response = await client.chat.completions.create(
  request,
  options?.signal ? { signal: options.signal } : undefined
);
```
Note: Groq SDK (based on OpenAI SDK) accepts request options as second parameter to `create()`, with a `signal` field.

For Gemini provider:
The Google GenerativeAI SDK `generateContent` accepts a `RequestOptions` parameter. Update the two `generateContent` calls:

For multimodal path (around line 366):
```typescript
const result = await model.generateContent(
  { contents: [{ role: 'user', parts }] },
  options?.signal ? { signal: options.signal } : undefined
);
```

Wait — checking the Google Generative AI SDK, `generateContent` accepts `(request, requestOptions?)` where `requestOptions` can include `signal`. Actually, let me verify: the `@google/generative-ai` SDK's `GenerativeModel.generateContent()` signature. Looking at the SDK source, requestOptions is part of the model configuration, not a separate parameter. Actually, the SDK uses `RequestOptions` which can be passed. Let me check the actual API:

The `@google/generative-ai` package's `GenerativeModel.generateContent()` signature is:
```
generateContent(request: GenerateContentRequest | string | Array<string | Part>): Promise<GenerateContentResult>
```

**Actually, the Google Generative AI SDK does NOT support AbortSignal directly in generateContent.** The SDK doesn't expose a signal parameter. For Gemini cancellation, we need a different approach:

**WORKAROUND for Gemini:** Wrap the Gemini call in a Promise.race with an abort listener:
```typescript
if (options?.signal?.aborted) throw new DOMException('Aborted', 'AbortError');

const geminiPromise = model.generateContent(prompt);
const abortPromise = options?.signal
  ? new Promise<never>((_, reject) => {
      options.signal!.addEventListener('abort', () => {
        reject(new DOMException('Aborted', 'AbortError'));
      }, { once: true });
    })
  : null;

const result = abortPromise
  ? await Promise.race([geminiPromise, abortPromise])
  : await geminiPromise;
```

Apply this pattern to BOTH Gemini paths (text-only and multimodal). Create a helper function to avoid duplication:

```typescript
/** Helper: race a promise against an abort signal */
async function withAbortSignal<T>(promise: Promise<T>, signal?: AbortSignal): Promise<T> {
  if (!signal) return promise;
  if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

  return Promise.race([
    promise,
    new Promise<never>((_, reject) => {
      signal.addEventListener('abort', () => {
        reject(new DOMException('Aborted', 'AbortError'));
      }, { once: true });
    }),
  ]);
}
```

Place this helper right before `generateCompletion` (in the UNIFIED COMPLETION API section).

Then for Gemini multimodal path:
```typescript
const result = await withAbortSignal(
  model.generateContent({ contents: [{ role: 'user', parts }] }),
  options?.signal
);
```

And for Gemini text-only path:
```typescript
const result = await withAbortSignal(
  model.generateContent(prompt),
  options?.signal
);
```

For OpenAI-compatible provider (around line 412):
```typescript
const response = await client.chat.completions.create(request);
```
Change to:
```typescript
const response = await client.chat.completions.create(
  request,
  options?.signal ? { signal: options.signal } : undefined
);
```
The OpenAI SDK accepts `RequestOptions` as second parameter with a `signal` field.

**3. Update `ChatCompletionOptions` interface** (around line 429):
Add `signal?: AbortSignal;` field:
```typescript
interface ChatCompletionOptions {
  provider?: string;
  modelId?: string;
  maxTokens?: number;
  signal?: AbortSignal;  // NEW: Enable cancellation
}
```

**4. Update `generateChatCompletion` function** to pass signal:

For Groq path:
```typescript
const response = await client.chat.completions.create({...},
  options?.signal ? { signal: options.signal } : undefined
);
```

For Gemini paths:
For single message path:
```typescript
const result = await withAbortSignal(
  model.generateContent(lastContent),
  options?.signal
);
```

For multi-turn path:
```typescript
const result = await withAbortSignal(
  chat.sendMessage(lastMessage.content),
  options?.signal
);
```

For OpenAI path:
```typescript
const response = await client.chat.completions.create({...},
  options?.signal ? { signal: options.signal } : undefined
);
```

**5. Update `withRateLimitRetry` to propagate abort:**
The existing `withRateLimitRetry` function doesn't check for abort. Add early abort check:
```typescript
async function withRateLimitRetry<T>(fn: () => Promise<T>, maxRetries = 3, baseDelayMs = 3000): Promise<T> {
  let lastError: unknown;
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (err) {
      lastError = err;
      // Don't retry abort errors
      if (isAbortError(err)) throw err;
      if (!isRateLimitError(err) || attempt === maxRetries) throw err;
      const backoffMs = baseDelayMs * Math.pow(2, attempt);
      await new Promise(r => setTimeout(r, backoffMs));
    }
  }
  throw lastError;
}
```

Import `isAbortError` from `./abort` at the top of the file.

**6. Update `generateCompletionWithRetry` to pass signal through:**
The function already calls `generateCompletion(prompt, { ...options, schema, images: options?.images })`. Since `options` now includes `signal`, it will naturally propagate. However, the inner retry calls also need signal:

In the retry fallback path (around line 646):
```typescript
return generateWithRetry(
  prompt,
  schema,
  (p) => withRateLimitRetry(() => generateCompletion(p, options)),
  1
);
```
This already passes `options` which includes `signal`. Good — no change needed here.

But check: in the first try block, `generateCompletion` is called with `{ ...options, schema, images: options?.images }`. This spreads `signal` from options. Good.

Also add early abort check at the start of `generateCompletionWithRetry`:
```typescript
// Check if already aborted
if (options?.signal?.aborted) {
  return { success: false, error: 'Operation cancelled', retryCount: 0 };
}
```

Wait — the function signature uses `Omit<CompletionOptions, 'schema'>` for options. Since CompletionOptions now has `signal`, it will be included in the spread. But `signal` is NOT in the omitted set, so it passes through correctly.

**7. Add `testProviderConnection` export** (for ai-health.ts from Plan 01):
Add at the end of the UNIFIED COMPLETION API section:
```typescript
/**
 * Test provider connectivity with minimal token usage.
 * Used by health check — no retry, no telemetry, no context.
 */
export async function testProviderConnection(providerId?: string): Promise<string> {
  return generateCompletion('Test', { provider: providerId, maxTokens: 5 });
}
```

**Summary of changes to ai.ts:**
- Import `isAbortError` from `./abort`
- Add `withAbortSignal` helper function
- Add `signal?: AbortSignal` to `CompletionOptions`
- Add `signal?: AbortSignal` to `ChatCompletionOptions`
- Pass signal to Groq SDK (2nd arg to create)
- Wrap Gemini calls with `withAbortSignal` (4 call sites)
- Pass signal to OpenAI SDK (2nd arg to create)
- Add abort check in `withRateLimitRetry`
- Add abort check in `generateCompletionWithRetry`
- Add `testProviderConnection` export
  </action>
  <verify>
1. `pnpm build` passes without TypeScript errors
2. Search for `signal` in ai.ts confirms it appears in CompletionOptions, ChatCompletionOptions, and all 3 provider SDK call sites
3. `withAbortSignal` helper exists
4. `isAbortError` is imported from `./abort`
5. `testProviderConnection` is exported
  </verify>
  <done>
AbortSignal propagates from CompletionOptions through generateCompletion to all 3 SDK clients (Groq via 2nd arg, Gemini via Promise.race wrapper, OpenAI via 2nd arg). ChatCompletion also supports signal. withRateLimitRetry skips retry on abort. generateCompletionWithRetry checks abort before starting. testProviderConnection exported for health check module.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes without errors
2. `CompletionOptions.signal` is optional AbortSignal
3. `ChatCompletionOptions.signal` is optional AbortSignal
4. All 3 provider paths in `generateCompletion` pass signal to SDK
5. All 3 provider paths in `generateChatCompletion` pass signal to SDK
6. `withRateLimitRetry` does not retry on AbortError
7. `generateCompletionWithRetry` has early abort check
8. `testProviderConnection` is exported
9. `withAbortSignal` helper handles Gemini SDK limitation
10. All existing callers continue to work without providing signal
</verification>

<success_criteria>
- Signal parameter exists in both CompletionOptions and ChatCompletionOptions
- Signal is forwarded to Groq, Gemini (via Promise.race), and OpenAI SDK calls
- Abort errors skip retry in withRateLimitRetry
- testProviderConnection exported for health check
- Zero TypeScript errors
- Backward compatible (signal is optional)
</success_criteria>

<output>
After completion, create `.planning/phases/24-validation-generation-ux/24-02-SUMMARY.md`
</output>
