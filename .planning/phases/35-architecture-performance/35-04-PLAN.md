---
phase: 35-architecture-performance
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/kanban/KanbanCard.tsx
  - src/components/list/ListView.tsx
autonomous: true
requirements: [FIX-12]
must_haves:
  truths:
    - "KanbanCard is wrapped in React.memo"
    - "ListView row component is wrapped in React.memo"
    - "ListView uses @tanstack/react-virtual for windowed rendering"
    - "Scrolling through 500+ items renders only visible rows in the DOM"
    - "pnpm build passes with zero TypeScript errors"
  artifacts:
    - path: "src/components/kanban/KanbanCard.tsx"
      provides: "React.memo-wrapped KanbanCard with stable prop comparison"
      contains: "React.memo"
    - path: "src/components/list/ListView.tsx"
      provides: "Virtualized table with @tanstack/react-virtual, memo-wrapped row"
      contains: "useVirtualizer"
  key_links:
    - from: "src/components/list/ListView.tsx"
      to: "@tanstack/react-virtual"
      via: "import { useVirtualizer } from '@tanstack/react-virtual'"
      pattern: "useVirtualizer"
    - from: "src/components/kanban/KanbanCard.tsx"
      to: "react"
      via: "React.memo wrapper"
      pattern: "memo\\("
---

<objective>
Wrap KanbanCard and ListView row in React.memo and add virtualization to ListView using @tanstack/react-virtual.

Purpose: Resolve SMELL-012 (all cards re-render on any item change; 100+ items means full re-render on drag-drop) and SMELL-013 (500+ items render all DOM nodes simultaneously causing scroll degradation).

Output: Memo-wrapped KanbanCard, memo-wrapped ListView row component, and virtualized ListView rendering only visible rows.
</objective>

<execution_context>
@C:/Users/Boris/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Boris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/kanban/KanbanCard.tsx
@src/components/list/ListView.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap KanbanCard in React.memo</name>
  <files>src/components/kanban/KanbanCard.tsx</files>
  <action>
Wrap the KanbanCard component in `React.memo` to prevent unnecessary re-renders when parent provides same props.

1. Add `memo` to the React import: `import { memo } from 'react';` (the file currently does not import from 'react' directly, so add this import)

2. Convert the named function export to a memo-wrapped component. There are two patterns; use the one that preserves the function name for DevTools:

```typescript
// Option: memo with named function
function KanbanCardInner({
  item,
  onClick,
  columnType,
  // ... all existing props
}: KanbanCardProps) {
  // ... existing function body unchanged
}

export const KanbanCard = memo(KanbanCardInner);
```

3. The component uses `useDraggable` from dnd-kit which injects transform/isDragging. Since these come from the dnd-kit context (not props), they will cause re-renders regardless of memo. However, memo still prevents re-renders when ONLY the parent's other items change (e.g., sibling card updates).

4. Do NOT add a custom comparison function — React's default shallow comparison is sufficient because:
   - `item` is a BacklogItem object that changes reference when updated (correct behavior)
   - Callback props (`onClick`, `onInlineUpdate`, etc.) should be stabilized with `useCallback` in the parent (already done in ProjectWorkspace)
   - Primitive props (`isSelected`, `isDragOverlay`) change correctly

5. Verify the export is still named `KanbanCard` (not `KanbanCardInner`) so all import sites work without changes.
  </action>
  <verify>Run `pnpm build` — must pass. Grep KanbanCard.tsx for `memo(` — should find one match. Grep for `export const KanbanCard = memo` — should match.</verify>
  <done>KanbanCard is wrapped in React.memo. Build passes. All import sites unaffected (export name preserved).</done>
</task>

<task type="auto">
  <name>Task 2: Wrap ListView row in React.memo and add virtualization</name>
  <files>src/components/list/ListView.tsx</files>
  <action>
This task has two parts: extract the table row into a memo-wrapped component, then integrate @tanstack/react-virtual.

**Part A: Extract and memo-wrap ListViewRow**

1. Add imports: `import { memo, useRef } from 'react';` (update existing import from 'react' which has `useState, useMemo`)
2. Add import: `import { useVirtualizer } from '@tanstack/react-virtual';`

3. Extract the `<motion.tr>` block (currently inline in the `sortedItems.map()`) into a separate `ListViewRow` component:

```typescript
interface ListViewRowProps {
  item: BacklogItem;
  aiScore: ItemPriorityScore | null;
  blockingInfo: BlockingBug | null;
  isSelected: boolean;
  hasAIAnalysis: boolean;
  severityOptions: InlineSelectOption<Severity>[];
  onRowClick: (item: BacklogItem, e: React.MouseEvent) => void;
  onInlineUpdate?: (itemId: string, updates: Partial<BacklogItem>) => void;
  onSelectionClick?: (itemId: string, event: { ctrlKey: boolean; metaKey: boolean; shiftKey: boolean }) => void;
  onQuickDelete?: (item: BacklogItem) => void;
  onQuickValidate?: (item: BacklogItem) => void;
  onQuickExport?: (item: BacklogItem) => void;
  onQuickArchive?: (item: BacklogItem) => void;
  t: ReturnType<typeof useTranslation>['t'];
}

const ListViewRow = memo(function ListViewRow({ item, aiScore, blockingInfo, isSelected, hasAIAnalysis, severityOptions, onRowClick, onInlineUpdate, onSelectionClick, onQuickDelete, onQuickValidate, onQuickExport, onQuickArchive, t }: ListViewRowProps) {
  // ... move the entire <motion.tr> content here (without the motion wrapper for virtualization)
  // Replace motion.tr with a regular <tr> since virtualized rows handle positioning differently
  // Keep all the cell rendering logic identical
  return (
    <tr
      onClick={(e) => onRowClick(item, e)}
      className={`group hover:bg-surface-alt cursor-pointer transition-colors ${
        isSelected ? 'bg-accent/10' : ''
      }`}
    >
      {/* ... all existing cells ... */}
    </tr>
  );
});
```

Note: With virtualization, remove `motion.tr` / `AnimatePresence` from the row level since virtualized rows are positioned absolutely and animation conflicts with virtual positioning. Keep `AnimatePresence` only if it does not interfere with virtual scrolling — if it does, remove it. The animation was nice-to-have but virtualization takes priority for performance.

**Part B: Integrate @tanstack/react-virtual (padding-based approach)**

Replace the current `<tbody>` rendering with a virtualized approach using **padding spacer rows** (NOT `position: absolute` on `<tr>` — absolute positioning on table rows is ignored by browser table layout engines).

```typescript
export function ListView({ items, onItemClick, ... }: ListViewProps) {
  const { t } = useTranslation();
  // ... existing sort state and handlers ...

  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: sortedItems.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 52, // Estimated row height in px (adjust based on actual row height — a row with badges is ~52px)
    overscan: 10, // Render 10 extra rows above/below viewport for smooth scrolling
  });

  const virtualItems = virtualizer.getVirtualItems();

  // Compute spacer heights for padding-based virtualization
  const paddingTop = virtualItems.length > 0 ? virtualItems[0].start : 0;
  const paddingBottom = virtualItems.length > 0
    ? virtualizer.getTotalSize() - virtualItems[virtualItems.length - 1].end
    : 0;

  // ... existing SortHeader component ...

  return (
    <div ref={parentRef} className="flex-1 overflow-auto">
      <table className="min-w-full">
        <thead className="bg-surface-alt sticky top-0 z-10">
          <tr>
            {/* ... existing header cells unchanged ... */}
          </tr>
        </thead>
        <tbody className="bg-surface divide-y divide-outline">
          {/* Top spacer row — creates empty space for items above the viewport */}
          {paddingTop > 0 && (
            <tr><td style={{ height: `${paddingTop}px` }} colSpan={999} /></tr>
          )}

          {/* Visible rows only */}
          {virtualItems.map(virtualRow => {
            const item = sortedItems[virtualRow.index];
            const aiScore = getItemScore?.(item.id) ?? null;
            const blockingInfo = getBlockingInfo?.(item.id) ?? null;
            const itemIsSelected = isSelected?.(item.id) ?? false;

            return (
              <ListViewRow
                key={item.id}
                item={item}
                aiScore={aiScore}
                blockingInfo={blockingInfo}
                isSelected={itemIsSelected}
                hasAIAnalysis={hasAIAnalysis}
                severityOptions={severityOptions}
                onRowClick={handleRowClick}
                onInlineUpdate={onInlineUpdate}
                onSelectionClick={onSelectionClick}
                onQuickDelete={onQuickDelete}
                onQuickValidate={onQuickValidate}
                onQuickExport={onQuickExport}
                onQuickArchive={onQuickArchive}
                t={t}
              />
            );
          })}

          {/* Bottom spacer row — creates empty space for items below the viewport */}
          {paddingBottom > 0 && (
            <tr><td style={{ height: `${paddingBottom}px` }} colSpan={999} /></tr>
          )}
        </tbody>
      </table>
    </div>
  );
}
```

**Do NOT add `style` prop to ListViewRowProps** — the padding-based approach does not require per-row positioning. Rows flow naturally in table layout; the spacer `<tr>` elements above and below create the scroll height illusion.

Important implementation notes:
- The `estimateSize` value should match typical row height. Use 52px as starting estimate.
- `overscan: 10` ensures smooth scrolling with 10 buffer rows.
- **Why padding-based instead of absolute positioning:** HTML `<tr>` elements inside `<tbody>` participate in table layout. Browsers override `position: absolute` on `<tr>`, making absolute-positioned rows collapse or overlap. The padding-based approach (from @tanstack/react-virtual's own table example) uses spacer rows to push visible rows to the correct scroll position while preserving native table column alignment.
- The top spacer row has height equal to `virtualItems[0].start` (all rows above viewport). The bottom spacer has height equal to `totalSize - lastItem.end` (all rows below viewport). This makes the scrollbar reflect the true total size.
- `colSpan={999}` on spacer `<td>` ensures the spacer spans all table columns regardless of column count changes.
- Remove the `AnimatePresence` + `motion.tr` wrappers — they conflict with virtualized rendering. The row enter/exit animations are sacrificed for virtualization performance.
- Import `motion` and `AnimatePresence` can be removed from the imports if no longer used elsewhere in the file.
- Keep the existing `SPRING_PRESETS` import removal if it's no longer used.
  </action>
  <verify>Run `pnpm build` — must pass. Verify ListView.tsx imports `useVirtualizer`. Verify `ListViewRow` is wrapped in `memo`. Check that the total number of rendered `<tr>` DOM nodes is limited (not equal to total items).</verify>
  <done>ListView uses @tanstack/react-virtual with ~52px row estimate and 10 overscan. ListViewRow is memo-wrapped. AnimatePresence removed from row level. Build passes.</done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with zero TypeScript errors
2. `pnpm test` — existing test suite remains green
3. KanbanCard.tsx contains `React.memo` wrapper
4. ListView.tsx contains `useVirtualizer` from `@tanstack/react-virtual`
5. ListView.tsx contains `memo(` wrapped row component
6. Grep for `<AnimatePresence` in ListView.tsx — should not wrap the tbody (may still exist for other purposes)
</verification>

<success_criteria>
- KanbanCard wrapped in React.memo — prevents re-render when sibling items change
- ListView uses @tanstack/react-virtual — only visible rows rendered in DOM
- ListView row component wrapped in React.memo
- Build passes; tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/35-architecture-performance/35-04-SUMMARY.md`
</output>
